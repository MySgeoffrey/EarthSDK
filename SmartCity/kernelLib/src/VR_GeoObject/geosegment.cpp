//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 蚂蚁空间信息平台
//  @ File Name : CGeoSegment.cpp
//  @ Date : 2017/8/21
//  @ Author : 
//
//


#include "geoobject/geosegment.h"
#include <osg/Geometry>
#include <osgEarthSymbology/Geometry>
#include <osgEarthFeatures/Feature>
#include <osgEarthAnnotation/PlaceNode>
#include <osgEarth/ElevationQuery>
#include <osgEarthAnnotation/CircleNode>
#include <osgEarthAnnotation/AnnotationEditing>
#include <osgEarthSymbology/GeometryFactory>
#include <osgEarthSymbology/Geometry>
#include <osg/LineWidth>
#include <osg/LineStipple>

using namespace osg;
using namespace osgEarth::Symbology;


namespace Geo
{
	CGeoSegment::CGeoSegment()
	{
		this->mPoints.resize(2);
		this->mpNode = NULL;
		this->mpGeometry = NULL;
	}

	CGeoSegment::CGeoSegment(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoSegment(pRefMapNode)
	{
		this->mPoints.resize(2);
		this->mpNode = NULL;
		this->mpGeometry = NULL;
		mLineColor = osg::Vec4f(1, 0, 0, 0.5);
		mLineWidth = 1.0;
		mLineType = 0;
	}

	CGeoSegment::~CGeoSegment()
	{
	
	}

	bool CGeoSegment::loadToScene()
	{
		bool r = false;
		if (this->mpLod)
			return r;
		osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;

		//osg::Vec4 color(1, 0, 0, 0.5);
		//double width = 1;

		//if (this->getStyle().get<osgEarth::Symbology::LineSymbol>())
		//{
		//	color = this->getStyle().get<LineSymbol>()->stroke()->color();
		//	width = this->getStyle().get<LineSymbol>()->stroke()->width().get();
		//}
		colors->push_back(mLineColor);
		osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
		std::vector<unsigned short> indices;
		indices.push_back(0);
		indices.push_back(1);

		vertices->push_back(osg::Vec3d(0,0,0));
		vertices->push_back(osg::Vec3d(0,0,1));
		
		unsigned short* pIndices = new unsigned short[indices.size()];
		for (int i = 0; i < indices.size(); ++i)
		{
			pIndices[i] = indices[i];
		}
		int numIndices = sizeof(pIndices) / sizeof(unsigned short);
		numIndices = indices.size();
		this->mpGeometry = new osg::Geometry;
		mpGeometry->setColorArray(colors.get());
		mpGeometry->setVertexArray(vertices.get());
		mpGeometry->setColorBinding(osg::Geometry::BIND_OVERALL);

		mpGeometry->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
		osg::StateSet* stateset = new osg::StateSet;  //透明属性设置
		stateset->setMode(GL_BLEND, osg::StateAttribute::ON); //Alpha混合开启 
		stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); //取消深度测试 
		stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF /*| osg::StateAttribute::PROTECTED*/);
		stateset->setAttribute(new osg::LineWidth(mLineWidth), osg::StateAttribute::ON);
		stateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
		stateset->setRenderBinDetails(5, "RenderBin");
		if(1 == mLineType)
		{
			osg::ref_ptr<osg::LineStipple> pLineStipple = new osg::LineStipple;
			pLineStipple->setFactor(1);
			pLineStipple->setPattern(0x3F3F);
			stateset->setAttributeAndModes(pLineStipple.get(),osg::StateAttribute::ON);
		}

		osg::Geode* pSegment = new osg::Geode;//扇体节点
		mpGeometry->setStateSet(stateset);
		pSegment->addDrawable(mpGeometry.get());
		pSegment->addDescription(std::string("segment"));

		osg::MatrixTransform* pRealSegment = new osg::MatrixTransform;
		pRealSegment->addChild(pSegment);

		osg::Matrixd worldMatrix = this->computeWorldMatrix();
		pRealSegment->setMatrix(worldMatrix);
		this->mpNode = pRealSegment;

		osg::LOD* pLod = new osg::LOD();
		pLod->addChild(pRealSegment, 0, 10000000000);
		this->mpLod = pLod;

		r = true;
		return r;
	}

	bool CGeoSegment::renderToScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() == 0)
		{
			setVisible(getVisible());
			this->mpRefMapNode->addChild(this->mpLod);
			r = true;
		}
		return r;
	}

	bool CGeoSegment::deRenderFromScene()
	{
		return false;
	}

	bool CGeoSegment::unLoadFromScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() > 0)
		{
			this->mpLod->getParent(0)->removeChild(this->mpLod);
			this->mpLod = NULL;
			this->mpNode = NULL;
			r = true;
		}
		return r;
	}

	osgEarth::Symbology::Style& CGeoSegment::getStyle()
	{
		return this->mStyle;
	}

	osg::Matrix CGeoSegment::computeWorldMatrix()
	{
		osg::Matrix worldMatrix = osg::Matrix::identity();
		osgEarth::GeoPoint startGeoPosition(this->getMapNode()->getMapSRS(),this->getStartPoint());
		osgEarth::GeoPoint endGeoPosition(this->getMapNode()->getMapSRS(),this->getEndPoint());

		osg::Vec3d startWorldPoint,endWorldPoint;
		startGeoPosition.toWorld(startWorldPoint);
		endGeoPosition.toWorld(endWorldPoint);

		osg::Vec3d localDirection(0,0,1);
		osg::Vec3d worldDirection = endWorldPoint - startWorldPoint;
		double length = worldDirection.normalize();

		osg::Vec3d realDir = worldDirection;
		realDir.normalize();

		osg::Quat q;
		q.makeRotate(localDirection,realDir);

		osg::Matrix translateMatix = osg::Matrix::translate(startWorldPoint);
		osg::Matrix rotateMatrix = osg::Matrix::rotate(q);		
		osg::Matrix scaleMatrix = osg::Matrix::scale(osg::Vec3d(1,1,length));

		worldMatrix = scaleMatrix * rotateMatrix * translateMatix;
		return worldMatrix;
	}

	void CGeoSegment::updateSceneObject()
	{
		if (this->mpNode)
		{
			osg::Matrix worldMatrix = this->computeWorldMatrix();
			osg::MatrixTransform* pSegmentNode =
				dynamic_cast<osg::MatrixTransform*>(this->mpNode);
			pSegmentNode->setMatrix(worldMatrix);
		}
	}

	void CGeoSegment::setColor( osg::Vec4f color )
	{
		mLineColor = color;
		if(mpGeometry)
		{
			osg::ref_ptr<osg::Vec4Array> colors = dynamic_cast<osg::Vec4Array*>(mpGeometry->getColorArray());
			colors->clear();
			colors->push_back(color);
			mpGeometry->dirtyDisplayList();
			mpGeometry->dirtyBound();
		}
	}

	osg::Vec4f CGeoSegment::getColor()
	{
		return mLineColor;
	}

	void CGeoSegment::setLineWidth( float width )
	{
		mLineWidth = width;
		if(mpGeometry)
		{
			osg::StateSet* stateset = mpGeometry->getOrCreateStateSet();
			stateset->setAttribute(new osg::LineWidth(width), osg::StateAttribute::ON);
		}
	}

	float CGeoSegment::getLineWidth()
	{
		return mLineWidth;
	}

	void CGeoSegment::setLineType( int type )
	{
		mLineType = type;
		if(mpGeometry)
		{
			osg::StateSet* stateset = mpGeometry->getOrCreateStateSet();
			if(0 == mLineType)
			{
				osg::ref_ptr<osg::LineStipple> pLineStipple = dynamic_cast<osg::LineStipple*>(
					stateset->getAttribute(osg::StateAttribute::LINESTIPPLE));
				if(pLineStipple)
				{
					//pLineGeom->getOrCreateStateSet()->setAttribute(pLineStipple.get(),osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE);
					pLineStipple->setFactor(1);
					pLineStipple->setPattern(0xFFFF);
					stateset->setAttributeAndModes(pLineStipple.get(),osg::StateAttribute::ON);
				}
			}
			else if(1 == mLineType)
			{
				osg::ref_ptr<osg::LineStipple> pLineStipple = new osg::LineStipple;
				pLineStipple->setFactor(1);
				pLineStipple->setPattern(0x3F3F);
				stateset->setAttributeAndModes(pLineStipple.get(),osg::StateAttribute::ON);
			}
		}
	}

	int CGeoSegment::getLineType()
	{
		return mLineType;
	}

}
