//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 蚂蚁空间信息平台
//  @ File Name : geopoint.cpp
//  @ Date : 2017/8/21
//  @ Author : 
//
//


#include "geoobject/geoscutcheon.h"
#include <osg/Geometry>
#include <osgEarthSymbology/Geometry>
#include <osgEarthFeatures/Feature>
#include <osgEarthAnnotation/PlaceNode>
#include <osgEarth/ElevationQuery>

#include <osgEarth/MapNode>
#include <osgEarth/Random>
#include <osgEarth/StringUtils>
#include <osgEarth/ImageUtils>
#include <osgEarth/GeoMath>
#include <osgEarth/Units>
#include <osgEarth/StringUtils>
#include <osgEarth/ScreenSpaceLayout>
#include <osgEarthUtil/ExampleResources>
#include <osgEarthUtil/EarthManipulator>
#include <osgEarthUtil/MGRSFormatter>
#include <osgEarthUtil/Controls>
#include <osgEarthUtil/AnnotationEvents>
#include <osgEarthUtil/HTM>
#include <osgEarthAnnotation/AnnotationData>
#include <osgEarthSymbology/Color>
#include <osgViewer/Viewer>
#include <osgViewer/ViewerEventHandlers>
#include <osgGA/StateSetManipulator>
#include "framework/common/globesetting.h"
#include "geoobject/customscutcheonnode.h"

using namespace osgEarth;
using namespace osgEarth::Util;
using namespace osgEarth::Util::Controls;
using namespace osgEarth::Annotation;
using namespace osgEarth::Symbology;

#define _USE_NEW_TYPE_ 1

int g_priority = 1;

// field names for the track labels
#define FIELD_TITLE "FIELD_TITLE"
#define FIELD_ID    "编号"
#define FIELD_LON	"经度"
#define FIELD_LAT   "纬度"
#define FIELD_ALT   "高度"

// icon to use, and size in pixels
#define BACKICON_URL       "systemImages/resources/image/pannelbackground.png"
#define TITLEICON_URL       "systemImages/resources/image/pannelbackground_title.png"
#define ICON_SIZE      140
#define TEXT_SIZE      -1

// format coordinates as MGRS
static MGRSFormatter s_format(MGRSFormatter::PRECISION_10000M);


namespace Geo
{
	std::string double2String(double value)
	{
		char str[200];
		sprintf(str,"%.6f\0",value);
		return str;
	}

	/**
	* Creates a field schema that we'll later use as a labeling template for
	* TrackNode instances.
	*/
	//void createFieldSchema(TrackNodeFieldSchema& schema)
	//{
	//	TextSymbol* titleSymbol = new TextSymbol();
	//	titleSymbol->pixelOffset()->set(0, 70);
	//	titleSymbol->alignment() = TextSymbol::ALIGN_CENTER_TOP;
	//	titleSymbol->halo()->color() = Color::Black;
	//	titleSymbol->fill()->color() = Color::Red;
	//	titleSymbol->size() = titleSymbol->size()->eval() + 10;
	//	titleSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
	//	titleSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
	//	//titleSymbol->declutter() = false;
	//	schema[FIELD_TITLE] = TrackNodeField(titleSymbol, true); // false => static label (won't change after set)

	//	// draw the track name above the icon:
	//	TextSymbol* nameSymbol = new TextSymbol();
	//	nameSymbol->pixelOffset()->set(-80, 0);
	//	nameSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
	//	nameSymbol->halo()->color() = Color::Black;
	//	nameSymbol->fill()->color() = Color::White;
	//	nameSymbol->size() = nameSymbol->size()->eval() + TEXT_SIZE;
	//	nameSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
	//	nameSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
	//	//nameSymbol->declutter() = false;
	//	schema[FIELD_ID] = TrackNodeField(nameSymbol, true); // false => static label (won't change after set)

	//	// draw the track coordinates below the icon:
	//	TextSymbol* posSymbol = new TextSymbol();
	//	posSymbol->pixelOffset()->set(-80, -30);
	//	posSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
	//	posSymbol->halo()->color() = Color::Black;
	//	posSymbol->fill()->color() = Color::White;
	//	posSymbol->size() = posSymbol->size()->eval() + TEXT_SIZE;
	//	posSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
	//	posSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
	//	//posSymbol->declutter() = false;
	//	schema[FIELD_LON] = TrackNodeField(posSymbol, true); // true => may change at runtime

	//	// draw some other field to the left:
	//	TextSymbol* numberSymbol = new TextSymbol();
	//	numberSymbol->pixelOffset()->set(-80, -60);//-2 - ICON_SIZE / 2
	//	numberSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
	//	numberSymbol->size() = numberSymbol->size()->eval() + TEXT_SIZE;
	//	numberSymbol->halo()->color() = Color::Black;
	//	numberSymbol->fill()->color() = Color::White;
	//	numberSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
	//	numberSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
	//	//numberSymbol->declutter() = false;
	//	schema[FIELD_LAT] = TrackNodeField(numberSymbol, true);

	//	TextSymbol* authorSymbol = new TextSymbol();
	//	authorSymbol->pixelOffset()->set(-80, -90);//-2 - ICON_SIZE / 2
	//	authorSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
	//	authorSymbol->size() = authorSymbol->size()->eval() + TEXT_SIZE;
	//	authorSymbol->halo()->color() = Color::Black;
	//	authorSymbol->fill()->color() = Color::White;
	//	authorSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
	//	authorSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
	//	//authorSymbol->declutter() = false;
	//	schema[FIELD_ALT] = TrackNodeField(authorSymbol, true);
	//}

	/** Builds a bunch of tracks. */

	
	CGeoScutcheon::CGeoScutcheon()
	{
		this->mpNode = NULL;
		this->mType = "Scutcheon";
		this->mSeparativeSign = " : ";
		this->mVerticalSpacing = 10;
		this->mIntervalBetweenTitleAndContent = 20;
		this->mIntervalBetweenBottomAndContent = 10;
		this->mBackImageScale = osg::Vec2d(1,1);
		this->mIntervalBetweenBottomAndContent = 10;
		this->mTitleImageOffset = 0;
		this->mContentHorizontalOffset = -65;
		this->mBackImageWidth = 175;
		this->mTitleImageScale = osg::Vec2d(1,1);
		this->mTitleImageSize = osg::Vec2s(120,40);
		this->mpRefScreenCamera = NULL;
		this->mpRefViewer = NULL;
		this->mpTitleSymbol = new osgEarth::Symbology::TextSymbol();
		{
			this->mpTitleSymbol->alignment() = TextSymbol::ALIGN_CENTER_TOP;
			this->mpTitleSymbol->halo()->color() = Color::Black;
			this->mpTitleSymbol->fill()->color() = Color::Red;
			this->mpTitleSymbol->size() = 17;
			this->mpTitleSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
			this->mpTitleSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
			this->mpTitleSymbol->declutter() = false;
		}
		this->mpContentSymbol = new osgEarth::Symbology::TextSymbol();
		{
			this->mpContentSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
			this->mpContentSymbol->halo()->color() = Color::Yellow;
			this->mpContentSymbol->fill()->color() = Color::Black;
			this->mpContentSymbol->size() = 14;
			this->mpContentSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
			this->mpContentSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
			this->mpContentSymbol->declutter() = false;
		}
		osgEarth::Symbology::Style& style = this->getStyle();
		style.getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral(
			BACKICON_URL);
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->font()= "fonts/simhei.ttf";//指定中文字体路径
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
		style.getOrCreate<osgEarth::Annotation::IconSymbol>()->alignment() = osgEarth::Annotation::IconSymbol::ALIGN_LEFT_TOP;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->declutter() = false;
		style.getOrCreate<osgEarth::Symbology::IconSymbol>()->declutter() = false;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloImplementation() = (osgText::Text::BackdropImplementation::STENCIL_BUFFER);
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->fill()->color() = (osg::Vec4(1, 1, 0, 1));
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->color() = (osg::Vec4(0, 0, 0, 1));
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->width() = 20;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloBackdropType() = (osgText::Text::BackdropType::OUTLINE);
		this->getTitleImageStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral(
			TITLEICON_URL);
		this->mFields.push_back(Field(FIELD_ID,this->getID()));
		this->mFields.push_back(Field(FIELD_LON,"116.003"));
		this->mFields.push_back(Field(FIELD_LAT,"32.001"));
		this->mFields.push_back(Field(FIELD_ALT,"0"));
		mScreenCoordinatesOffset = osg::Vec2s(0.0,0.0);
		this->mTitleImageSize = osg::Vec2s(120,40);
	}

	CGeoScutcheon::CGeoScutcheon(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoPoint(pRefMapNode)
	{
		this->mpNode = NULL;
		this->mType = "Scutcheon";
		this->mSeparativeSign = " : ";
		this->mVerticalSpacing = 10;
		this->mIntervalBetweenTitleAndContent = 20;
		this->mBackImageScale = osg::Vec2d(1,1);
		this->mIntervalBetweenBottomAndContent = 10;
		this->mTitleImageOffset = 0;
		this->mContentHorizontalOffset = -65;
		this->mBackImageWidth = 175;
		this->mTitleImageScale = osg::Vec2d(1,1);
		this->mTitleImageSize = osg::Vec2s(120,40);
		this->mpRefScreenCamera = NULL;
		this->mpRefViewer = NULL;
		this->mpTitleSymbol = new osgEarth::Symbology::TextSymbol();
		{
			this->mpTitleSymbol->alignment() = TextSymbol::ALIGN_CENTER_TOP;
			this->mpTitleSymbol->halo()->color() = Color::Black;
			this->mpTitleSymbol->fill()->color() = Color::Red;
			this->mpTitleSymbol->size() = this->mpTitleSymbol->size()->eval();
			this->mpTitleSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
			this->mpTitleSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
			this->mpTitleSymbol->declutter() = false;
		}
		this->mpContentSymbol = new osgEarth::Symbology::TextSymbol();
		{
			this->mpContentSymbol->alignment() = TextSymbol::ALIGN_LEFT_BASE_LINE;
			this->mpContentSymbol->halo()->color() = Color::Black;
			this->mpContentSymbol->fill()->color() = Color::White;
			this->mpContentSymbol->size() = this->mpContentSymbol->size()->eval() + TEXT_SIZE;
			this->mpContentSymbol->font() = "fonts/simhei.ttf";//指定中文字体路径
			this->mpContentSymbol->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
			this->mpContentSymbol->declutter() = false;
		}
		osgEarth::Symbology::Style& style = this->getStyle();
		style.getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral(
			BACKICON_URL);
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->font()= "fonts/simhei.ttf";//指定中文字体路径
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
		style.getOrCreate<osgEarth::Annotation::IconSymbol>()->alignment() = osgEarth::Annotation::IconSymbol::ALIGN_LEFT_TOP;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->declutter() = false;
		style.getOrCreate<osgEarth::Symbology::IconSymbol>()->declutter() = false;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->encoding() = osgEarth::Symbology::TextSymbol::ENCODING_UTF8;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloImplementation() = (osgText::Text::BackdropImplementation::STENCIL_BUFFER);
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->fill()->color() = (osg::Vec4(1, 1, 0, 1));
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->color() = (osg::Vec4(0, 0, 0, 1));
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->width() = 20;
		style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloBackdropType() = (osgText::Text::BackdropType::OUTLINE);
		this->getTitleImageStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral(
			TITLEICON_URL);
		this->getTitleImageStyle().getOrCreate<osgEarth::Annotation::TextSymbol>()->declutter() = false;
		this->getTitleImageStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->declutter() = false;
		this->mFields.push_back(Field(FIELD_ID,this->getID()));
		this->mFields.push_back(Field(FIELD_LON,"116.003"));
		this->mFields.push_back(Field(FIELD_LAT,"32.001"));
		this->mFields.push_back(Field(FIELD_ALT,"0.0003"));
		mScreenCoordinatesOffset = osg::Vec2s(0.0,0.0);
		this->mTitleImageSize = osg::Vec2s(120,40);
	}

	CGeoScutcheon::~CGeoScutcheon()
	{
		if (this->mpTitleSymbol)
		{
			delete this->mpTitleSymbol;
			this->mpTitleSymbol = NULL;
		}

		if (this->mpContentSymbol)
		{
			delete this->mpContentSymbol;
			this->mpContentSymbol = NULL;
		}
	}

	void CGeoScutcheon::setViewer(osgViewer::Viewer* pRefViewer)
	{
		this->mpRefViewer = pRefViewer;
	}

	osgViewer::Viewer* CGeoScutcheon::getViewer()
	{
		return this->mpRefViewer;
	}

	void CGeoScutcheon::setScreenCamera(osg::Camera* pScreenCamera)
	{
		this->mpRefScreenCamera = pScreenCamera;
	}

	osg::Camera* CGeoScutcheon::getScreenCamera()
	{
		return this->mpRefScreenCamera;
	}

	double CGeoScutcheon::createFieldSchema(TrackNodeFieldSchema& schema)
	{
#if 1
		Fields validFields;
		Fields& fields = this->getFields();
		for (int i = 0; i < fields.size(); ++i)
		{
			if (fields.at(i).valid)
			{
				validFields.push_back(fields.at(i));
			}
		}
		double totalHeight = 0;
		//标头距离背景的高度差
		totalHeight += this->getTitleImageOffset();
		//标头图片的高度
		totalHeight += this->mTitleImageSize.y();
		//文字内容距离标头图片的距离
		totalHeight += this->getIntervalBetweenTitleAndContent();
		double fontSize = this->mpContentSymbol->size()->eval();
		//文字的高度
		if (validFields.size() > 0)
		{
			totalHeight += (validFields.size() - 1) * this->getVerticalSpacing();
			totalHeight += validFields.size() * fontSize;
		}
		//文字内容距离背景图片底部的距离
		totalHeight += this->getIntervalBetweenBottomAndContent();
		osg::Image* pBackImage = this->getStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->getImage();
		//用户图片高度为212,用户图片宽度为175
		double imageHeight = 212,imageWidth = 175;
		if (pBackImage)
		{
			imageWidth = (double)pBackImage->s();
			imageHeight = (double)pBackImage->t();
		}
		double heightScale = totalHeight / imageHeight;
		double widthScale = this->getBackImageWidth() / imageWidth;
		//背景图片的缩放系数
		this->mBackImageScale = osg::Vec2d(widthScale,heightScale);

		imageWidth = 120;
		imageHeight = 40;
		osg::Image* pTitleImage = this->getTitleImageStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->getImage();
		if (pTitleImage)
		{
			imageWidth = (double)pTitleImage->s();
			imageHeight = (double)pTitleImage->t();
		}
		//标头图片缩放系数
		double widthTitleScale = this->getTitleImageSize().x() / imageWidth;
		double heightTitleScale = this->getTitleImageSize().y() / imageHeight;
		this->mTitleImageScale = osg::Vec2d(widthTitleScale,heightTitleScale);

		//创建标头文字风格
		TextSymbol* titleSymbol = new TextSymbol(*this->mpTitleSymbol);
		double titleOffset = totalHeight / 2 - this->getTitleImageSize().y() / 2.0 - this->getTitleImageOffset();//topOffset
		this->getTitleImageStyle().getOrCreate<osgEarth::Symbology::TextSymbol>()->pixelOffset() = osg::Vec2s(0,titleOffset);

		titleSymbol->pixelOffset()->set(0, titleOffset + titleSymbol->size()->eval() / 2);
		schema[FIELD_TITLE] = TrackNodeField(titleSymbol, true); 
		
		//创建内容风格
		if (!validFields.empty())
		{
			double hOffset = this->getContentHorizontalOffset();
			double vOffset = (titleOffset - this->getTitleImageSize().y() / 2.0 - this->getIntervalBetweenTitleAndContent() - fontSize / 2.0);
			for (int i = 0; i < validFields.size(); ++i)
			{
				Field& field = validFields[i];
				TextSymbol* pSymbol = new TextSymbol(*this->mpContentSymbol);
				pSymbol->pixelOffset()->set(hOffset, vOffset - i * (fontSize + this->getVerticalSpacing()));//-2 - ICON_SIZE / 2
				schema[field.name] = TrackNodeField(pSymbol, true);
			}
			
		}
		return totalHeight;
#else

		Fields validFields;
		Fields& fields = this->getFields();
		for (int i = 0; i < fields.size(); ++i)
		{
			if (fields.at(i).valid)
			{
				validFields.push_back(fields.at(i));
			}
		}
		//
		double imageHeight = 212;//用户图片高度为212
		double imageWidth = 175;//用户图片宽度为175
		double titleImageHeight = 20;
		double topOffset = 20;
		double bottomOffset = this->getIntervalBetweenBottomAndContent();
		double fontSize = this->mpContentSymbol->size()->eval();
		double vInterval = this->getVerticalSpacing();
		//创建标头风格
		TextSymbol* titleSymbol = new TextSymbol(*this->mpTitleSymbol);
		double intervalBetweenTitleAndContent = this->getIntervalBetweenTitleAndContent();
		double totalHeight = topOffset 
			+ titleSymbol->size()->eval() * 1.2 
			+ intervalBetweenTitleAndContent + this->getIntervalBetweenBottomAndContent();
		if (validFields.size() > 0)
		{
			totalHeight += (validFields.size() - 1) * (fontSize + vInterval);
		}
		totalHeight += bottomOffset;
		
		double heightScale = totalHeight / imageHeight;
		double widthScale = this->getBackImageWidth() / imageWidth;
		this->mBackImageScale = osg::Vec2d(widthScale,heightScale);
		this->getStyle().getOrCreate<osgEarth::Annotation::IconSymbol>()->scale() = heightScale;
		double titleOffset = totalHeight / 2 - 10 - this->getTitleImageOffset();//topOffset
		titleSymbol->pixelOffset()->set(0, titleOffset);
		schema[FIELD_TITLE] = TrackNodeField(titleSymbol, true); // false => static label (won't change after set)
		this->getTitleImageStyle().getOrCreate<osgEarth::Symbology::TextSymbol>()->pixelOffset() = osg::Vec2s(0,titleOffset - titleSymbol->size()->eval() / 2);
		//创建内容风格
		if (!validFields.empty())
		{
			double hOffset = this->getContentHorizontalOffset();
			/*double vOffset = 30 * scale;*/
			double vOffset = (titleOffset - titleSymbol->size()->eval() * 2 - intervalBetweenTitleAndContent);
			for (int i = 0; i < validFields.size(); ++i)
			{
				Field& field = validFields[i];
				TextSymbol* pSymbol = new TextSymbol(*this->mpContentSymbol);
				pSymbol->pixelOffset()->set(hOffset, vOffset - i * (fontSize + vInterval));//-2 - ICON_SIZE / 2
				schema[field.name] = TrackNodeField(pSymbol, true);
			}
			
		}
		return totalHeight;
#endif
	}

	osg::Node* CGeoScutcheon::createTrackNode(MapNode* mapNode,
		const TrackNodeFieldSchema& schema,
		const double& lon,
		const double& lat,
		const double& alt)
	{
		//// load an icon to use:
		/*osg::ref_ptr<osg::Image> srcImage = osgDB::readImageFile(ICON_URL);
		osg::ref_ptr<osg::Image> image;
		ImageUtils::resizeImage(srcImage.get(), 240, 300, image);*/

		//// make some tracks, choosing a random simulation for each.
		//Random prng;
		const SpatialReference* geoSRS = mapNode->getMapSRS()->getGeographicSRS();

		GeoPoint pos(geoSRS, lon, lat, alt);
#if _USE_NEW_TYPE_ == 1	
		CGeoScutcheonNode* track = new CGeoScutcheonNode(
			mapNode, pos, 
			this->getStyle(),this->getTitleImageStyle(),
			schema,this->mBackImageScale,this->mTitleImageScale,
			this->getViewer(),
			this->getScreenCamera());
		//// add a priority
		//track->setOcclusionCulling(false);
		//track->setPriority(FLT_MAX);//FLT_MAX FLT_MAX  - g_priority++ 
		return track;
#else
		CScutcheonNode* track = new CScutcheonNode(
			mapNode, pos, 
			this->getStyle(),this->getTitleImageStyle(),
			schema,this->mBackImageScale,this->mTitleImageScale/*,
			this->getViewer()*/);
		// add a priority
		track->setOcclusionCulling(false);
		track->setPriority(FLT_MAX);//FLT_MAX FLT_MAX  - g_priority++ 
		return track;
#endif
		
	}

	bool CGeoScutcheon::loadToScene()
	{
		bool r = false;
		if (NULL != this->mpLod)
			return r;
		createFieldSchema(this->mTrackNodeFieldSchema);
		osg::Node* trackNode = createTrackNode(this->mpRefMapNode, 
			this->getTrackNodeFieldSchema(),
			this->getGeoPosition().x(), 
			this->getGeoPosition().y(),
			this->getGeoPosition().z() );

		//this->mObjectId = osgEarth::Registry::objectIndex()->tagNode(trackNode, this);
		if (NULL == this->mpLod)
		{
			this->mpLod = new osg::LOD();
		}
		this->mpNode = trackNode;
		this->mpLod->addChild(trackNode, 0, 200000000);
		this->updateContent();
		setVisible(getVisible());
		this->setScreenCoordinatesOffset(this->getScreenCoordinatesOffset());
		r = true;
		return r;
	}

	bool CGeoScutcheon::renderToScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() == 0)
		{
			//this->mpRefMapNode->addChild(this->mpLod);
			this->getScreenCamera()->addChild(this->mpLod);
			r = true;
		}
		return r;
	}

	bool CGeoScutcheon::deRenderFromScene()
	{
		bool r = false;

		return r;
	}

	bool CGeoScutcheon::unLoadFromScene()
	{
		bool r = false;
		if (this->mpLod)
		{
			if (this->mpLod->getNumParents() > 0)
			{
				this->getScreenCamera()->removeChild(this->mpLod);
				//this->mpLod->getParent(0)->removeChild(this->mpLod);
			}
			this->mpLod = NULL;
			r = true;
		}
		return r;
	}

	double CGeoScutcheon::contain(const int& x, const int& y ,osg::Camera* pCamera)
	{
		double r = 0;
#if _USE_NEW_TYPE_ == 1
		if (this->mpNode)
		{
			CGeoScutcheonNode * pScutcheonNode = 
				dynamic_cast<CGeoScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				r = pScutcheonNode->contain(x,y,pCamera);
			}
		}
#endif
		return r;
	}

	osgEarth::Symbology::Style& CGeoScutcheon::getStyle()
	{
		return this->mStyle;
	}

	osgEarth::Symbology::Style& CGeoScutcheon::getTitleImageStyle()
	{
		return this->mTitleImageStyle;
	}

	osgEarth::Symbology::TextSymbol* CGeoScutcheon::getTitleSymbol()
	{
		return this->mpTitleSymbol;
	}

	osgEarth::Symbology::TextSymbol* CGeoScutcheon::getContentSymbol()
	{
		return this->mpContentSymbol;
	}

	TrackNodeFieldSchema& CGeoScutcheon::getTrackNodeFieldSchema()
	{
		return this->mTrackNodeFieldSchema;
	}

	void CGeoScutcheon::updateContent()
	{
		if (this->mpNode)
		{
			
#if _USE_NEW_TYPE_ == 1
			CGeoScutcheonNode* trackNode = dynamic_cast<CGeoScutcheonNode*>(this->mpNode);
			Fields validFields;
			Fields& fields = this->getFields();
			for (int i = 0; i < fields.size(); ++i)
			{
				if (fields.at(i).valid)
				{
					validFields.push_back(fields.at(i));
				}
			}
			osgText::Text* drawable = dynamic_cast<osgText::Text*>(trackNode->getDrawable(FIELD_TITLE));
			if (drawable)
			{
				std::string content = CGlobeSetting::instance()->gbkToUTF8(this->getName());
				drawable->setText(content, osgText::String::ENCODING_UTF8);
			}
			
			for (int i = 0; i < validFields.size(); ++i)
			{
				Field& field = validFields.at(i);
				std::string intervalStr = this->getSeparativeSign();
				intervalStr = CGlobeSetting::instance()->gbkToUTF8(intervalStr);
				std::string content = Stringify() << field.name << intervalStr << field.value;
				drawable = dynamic_cast<osgText::Text*>(trackNode->getDrawable(field.name));
				if (drawable)
				{
					content = CGlobeSetting::instance()->gbkToUTF8(content);
					drawable->setText(content, osgText::String::ENCODING_UTF8);
				}
			}
#else
			CScutcheonNode* trackNode = dynamic_cast<CScutcheonNode*>(this->mpNode);
			Fields validFields;
			Fields& fields = this->getFields();
			for (int i = 0; i < fields.size(); ++i)
			{
				if (fields.at(i).valid)
				{
					validFields.push_back(fields.at(i));
				}
			}
			osgText::Text* drawable = dynamic_cast<osgText::Text*>(trackNode->getDrawable(FIELD_TITLE));
			if (drawable)
			{
				std::string content = CGlobeSetting::instance()->gbkToUTF8(this->getName());
				drawable->setText(content, osgText::String::ENCODING_UTF8);
			}
			
			for (int i = 0; i < validFields.size(); ++i)
			{
				Field& field = validFields.at(i);
				std::string intervalStr = this->getSeparativeSign();
				intervalStr = CGlobeSetting::instance()->gbkToUTF8(intervalStr);
				std::string content = Stringify() << field.name << intervalStr << field.value;
				drawable = dynamic_cast<osgText::Text*>(trackNode->getDrawable(field.name));
				if (drawable)
				{
					content = CGlobeSetting::instance()->gbkToUTF8(content);
					drawable->setText(content, osgText::String::ENCODING_UTF8);
				}
			}
#endif
		}
	}

	void CGeoScutcheon::updateSceneObject()
	{
		if (NULL != this->mpNode)
		{
#if _USE_NEW_TYPE_ == 1
			CGeoScutcheonNode * pScutcheonNode = 
				dynamic_cast<CGeoScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				this->updateContent();
				osg::Vec3d worldPosition;
				osgEarth::GeoPoint geoPoint(this->getMapNode()->getMapSRS(),this->getGeoPosition());
				geoPoint.toWorld(worldPosition);
				pScutcheonNode->updateWorldPosition(worldPosition);
			}
#else
			CScutcheonNode * pScutcheonNode = 
				dynamic_cast<CScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				this->updateContent();
				osg::Vec3d worldPosition;
				osgEarth::GeoPoint geoPoint(this->getMapNode()->getMapSRS(),this->getGeoPosition());
				geoPoint.toWorld(worldPosition);
				pScutcheonNode->getGeoTransform()->setMatrix(osg::Matrix::translate(worldPosition));
			}
#endif
		}
	}

	Fields& CGeoScutcheon::getFields()
	{
		return this->mFields;
	}

	void CGeoScutcheon::setScreenCoordinatesOffset( const osg::Vec2s& offset )
	{
		mScreenCoordinatesOffset = offset;
		if (NULL != this->mpNode)
		{
#if _USE_NEW_TYPE_ == 1
			CGeoScutcheonNode* pScutcheonNode = 
				dynamic_cast<CGeoScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				pScutcheonNode->updateLayoutData(offset);
			}
#else
			CScutcheonNode* pScutcheonNode = 
				dynamic_cast<CScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				pScutcheonNode->updateLayoutData(offset);
			}
#endif
		}
	}

	osg::Vec2s CGeoScutcheon::getScreenCoordinatesOffset()
	{
		return mScreenCoordinatesOffset;
	}

	std::string CGeoScutcheon::getSeparativeSign()
	{
		return this->mSeparativeSign;
	}

	void CGeoScutcheon::setSeparativeSign(const std::string& separativeSign)
	{
		this->mSeparativeSign = separativeSign;
	}

	int CGeoScutcheon::getVerticalSpacing()
	{
		return this->mVerticalSpacing;
	}

	int CGeoScutcheon::getIntervalBetweenTitleAndContent()
	{
		return this->mIntervalBetweenTitleAndContent;
	}

	void CGeoScutcheon::setIntervalBetweenTitleAndContent(const int& intervalBetweenTitleAndContent)
	{
		this->mIntervalBetweenTitleAndContent = intervalBetweenTitleAndContent;
	}

	int CGeoScutcheon::getIntervalBetweenBottomAndContent()
	{
		return this->mIntervalBetweenBottomAndContent;
	}

	void CGeoScutcheon::setIntervalBetweenBottomAndContent(const int& intervalBetweenBottomAndContent)
	{
		this->mIntervalBetweenBottomAndContent = intervalBetweenBottomAndContent;
	}

	int CGeoScutcheon::getContentHorizontalOffset()
	{
		return this->mContentHorizontalOffset;
	}

	void CGeoScutcheon::setContentHorizontalOffset(const int& contentHorizontalOffset)
	{
		this->mContentHorizontalOffset = contentHorizontalOffset;
	}

	void CGeoScutcheon::setVerticalSpacing(const int& verticalSpacing)
	{
		this->mVerticalSpacing = verticalSpacing;
	}

	int CGeoScutcheon::getTitleImageOffset()
	{
		return this->mTitleImageOffset;
	}

	void CGeoScutcheon::setTitleImageOffset(const int& titleImageOffset)
	{
		this->mTitleImageOffset = titleImageOffset;
	}

	void CGeoScutcheon::setTitleImageSize(const osg::Vec2s& titleImageSize)
	{
		this->mTitleImageSize = titleImageSize;
	}

	osg::Vec2s CGeoScutcheon::getTitleImageSize()
	{
		return this->mTitleImageSize;
	}

	void CGeoScutcheon::setBackImageWidth(const int& backImageWidth)
	{
		this->mBackImageWidth = backImageWidth;
	}

	int CGeoScutcheon::getBackImageWidth()
	{
		return this->mBackImageWidth;
	}

	osg::Vec3d CGeoScutcheon::getNearWorldPointToOrigin(osg::Camera* pCamera)
	{
		if (NULL != this->mpNode)
		{
#if _USE_NEW_TYPE_ == 1
			CGeoScutcheonNode * pScutcheonNode = 
				dynamic_cast<CGeoScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				return pScutcheonNode->getNearWorldPointToOrigin(pCamera);
			}
#else
			/*CScutcheonNode * pScutcheonNode = 
				dynamic_cast<CScutcheonNode*>(this->mpNode);
			if (pScutcheonNode)
			{
				this->updateContent();
				osg::Vec3d worldPosition;
				osgEarth::GeoPoint geoPoint(this->getMapNode()->getMapSRS(),this->getGeoPosition());
				geoPoint.toWorld(worldPosition);
				pScutcheonNode->getGeoTransform()->setMatrix(osg::Matrix::translate(worldPosition));
			}*/
#endif
		}
		return osg::Vec3d(0,0,0);
	}
}
