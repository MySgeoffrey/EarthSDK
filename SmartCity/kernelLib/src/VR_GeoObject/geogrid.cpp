//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 蚂蚁空间信息平台
//  @ File Name : geopoint.cpp
//  @ Date : 2017/8/21
//  @ Author : 
//
//


#include "geoobject/geogrid.h"
#include <osg/Geometry>
#include <osgEarthSymbology/Geometry>
#include <osgEarthFeatures/Feature>
#include <osgEarthAnnotation/PlaceNode>
#include <osgEarth/ElevationQuery>
#include <osgEarthAnnotation/CircleNode>
#include <osgEarthAnnotation/AnnotationEditing>
#include <osgEarthSymbology/GeometryFactory>
#include <osgEarthSymbology/Geometry>
#include <osg/LineWidth>

using namespace osg;
using namespace osgEarth::Symbology;

#define  d2r 3.1415926535898 / 180.0

namespace Geo
{
	CGeoRingGrid::CGeoRingGrid()
	{
		this->mpNode = NULL;
		this->mType = "geoRingGrid";
		this->mRadius = 1000;
		this->mSectorCount = 8;
		this->mSubRingCount = 3;
		Style& circleStyle = this->getStyle();
		circleStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		circleStyle.getOrCreate<LineSymbol>()->stroke()->width() = 3.0f;
		circleStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;// CLAMP_TO_TERRAIN;// ;
		circleStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;//DRAPE
		circleStyle.getOrCreate<osgEarth::Symbology::AltitudeSymbol>()->verticalOffset() = 0.1;
		//circleStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;// CLAMP_TO_TERRAIN;// ;
		//circleStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;//DRAPE
	}

	CGeoRingGrid::CGeoRingGrid(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoPoint(pRefMapNode)
	{
		this->mpNode = NULL;
		this->mType = "geoRingGrid";
		this->mRadius = 1000;
		this->mSectorCount = 8;
		this->mSubRingCount = 3;
		Style& circleStyle = this->getStyle();
		circleStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		circleStyle.getOrCreate<LineSymbol>()->stroke()->width() = 3.0f;
		circleStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;// CLAMP_TO_TERRAIN;// ;
		circleStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;//DRAPE
		circleStyle.getOrCreate<osgEarth::Symbology::AltitudeSymbol>()->verticalOffset() = 0.1;
	}

	CGeoRingGrid::~CGeoRingGrid()
	{
	
	}

	void CGeoRingGrid::setRadius(const double& radius)
	{
		this->mRadius = radius;
	}

	double CGeoRingGrid::getRadius()
	{
		return this->mRadius;
	}

	bool CGeoRingGrid::loadToScene()
	{
		bool r = false;
		
        double segLen = this->getRadius() / 30.0;
        double circumference = 2 * osg::PI * this->getRadius();
        double numSegments = (unsigned)::ceil(circumference / segLen);
		osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;//扇形顶点
		osg::ref_ptr<osg::Vec3Array> centerVertices = new osg::Vec3Array;//扇形顶点
		double startAngle = 0 * d2r;
		double endAngle = 360 * d2r;
		double deltaAngle = (endAngle - startAngle) / numSegments;
		osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
		
		osg::Vec4 color(1,0,0,0.5);
		double width = 1;

		if (this->getStyle().get<osgEarth::Symbology::LineSymbol>())
		{
			color = this->getStyle().get<LineSymbol>()->stroke()->color();
			width = this->getStyle().get<LineSymbol>()->stroke()->width().get();
		}
		colors->push_back(color);

		int realAreaCount = this->getSubRingCount() + 1;
		double perAreaRadius = 1.0 / realAreaCount;
		std::vector<unsigned short> indices;
		for (int n = 0; n <= this->getSubRingCount(); ++n)
		{
			double curRadius = (n + 1) * perAreaRadius;
			for (int i = 0; i <= numSegments; ++i)
			{
				double radAngle = startAngle + i * deltaAngle;
				osg::Vec3d top = osg::Vec3(curRadius * sin(radAngle), curRadius * cos(radAngle), 0);
				vertices->push_back(top);

				if (i > 0)
				{
					indices.push_back(vertices->size() -1 - 1);
					indices.push_back(vertices->size() - 1);
				}
			}
		}

#if 1
		int sectorCount = this->getSectorCount();
		deltaAngle = 360.0  * d2r / sectorCount;
		for (int i = 0; i <= sectorCount; ++i)
		{
			indices.push_back(vertices->size());
			indices.push_back(vertices->size() + 1);

			double radAngle = i * deltaAngle;
			osg::Vec3d top = osg::Vec3(sin(radAngle), cos(radAngle), 0);
			osg::Vec3d center = osg::Vec3(0, 0, 0);
			vertices->push_back(center);
			vertices->push_back(top);
		}
#endif
		
		unsigned short* pIndices = new unsigned short[indices.size()];
		for (int i = 0; i < indices.size(); ++i)
		{
			pIndices[i] = indices[i];
		}
		int numIndices = sizeof(pIndices) / sizeof(unsigned short);
		numIndices = indices.size();
		osg::ref_ptr<osg::Geometry>geomTri = new osg::Geometry;
		geomTri->setColorArray(colors.get());
		geomTri->setVertexArray(vertices.get());
		geomTri->setColorBinding(osg::Geometry::BIND_OVERALL);

		geomTri->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
		osg::StateSet* stateset = new osg::StateSet;  //透明属性设置
		stateset->setMode(GL_BLEND, osg::StateAttribute::ON); //Alpha混合开启 
		stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); //取消深度测试 
		stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF /*| osg::StateAttribute::PROTECTED*/);
		stateset->setAttribute(new osg::LineWidth(width), osg::StateAttribute::ON);
		stateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
		stateset->setRenderBinDetails(5, "RenderBin");

		osg::Geode* circle = new osg::Geode;//扇体节点
		geomTri->setStateSet(stateset);
		circle->addDrawable(geomTri.get());
		circle->addDescription(std::string("ringGrid"));

		osg::ref_ptr<osg::MatrixTransform> pRealCircle = new osg::MatrixTransform;
		pRealCircle->addChild(circle);

		osg::Matrixd worldMatrix;
		this->getMapNode()->getMap()->getSRS()->getEllipsoid()->computeLocalToWorldTransformFromLatLongHeight(
			osg::DegreesToRadians(this->getGeoPosition().y()),
			osg::DegreesToRadians(this->getGeoPosition().x()),
			this->getGeoPosition().z(), worldMatrix);
		pRealCircle->setMatrix(osg::Matrix::scale(this->getRadius(),this->getRadius(),1) * worldMatrix);

		osg::LOD* pLod = new osg::LOD();
		pLod->addChild(pRealCircle, 0, 10000000000);
		this->mpNode = pLod;
		r = true;
		return r;
	}

	bool CGeoRingGrid::renderToScene()
	{
		bool r = false;
		if (this->mpNode && this->mpNode->getNumParents() == 0)
		{
			this->mpRefMapNode->addChild(this->mpNode);
			r = true;
		}
		return r;
	}

	bool CGeoRingGrid::deRenderFromScene()
	{
		return unLoadFromScene();
	}

	bool CGeoRingGrid::unLoadFromScene()
	{
		bool r = false;
		if (this->mpNode && this->mpNode->getNumParents() > 0)
		{
			this->mpNode->getParent(0)->removeChild(this->mpNode);
			this->mpNode = NULL;
			r = true;
		}
		return r;
	}

	osgEarth::Symbology::Style& CGeoRingGrid::getStyle()
	{
		return this->mStyle;
	}

	void CGeoRingGrid::setSubRingCount(const int& ringCount)
	{
		this->mSubRingCount = ringCount;
	}

	int CGeoRingGrid::getSubRingCount()
	{
		return this->mSubRingCount;
	}

	void CGeoRingGrid::setSectorCount(const int& sectorCount)
	{
		this->mSectorCount = sectorCount;
	}

	int CGeoRingGrid::getSectorCount()
	{
		return this->mSectorCount;
	}

	CGeoRectGrid::CGeoRectGrid()
	{
		this->mpNode = NULL;
		this->mType = "geoRingGrid";
		this->mWdith = 1000;
		this->mHeight = 1000;
		this->mRowCount = 4;
		this->mColCount = 4;
		Style& circleStyle = this->getStyle();
		circleStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		circleStyle.getOrCreate<LineSymbol>()->stroke()->width() = 3.0f;
		circleStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;// CLAMP_TO_TERRAIN;// ;
		circleStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;//DRAPE
		circleStyle.getOrCreate<osgEarth::Symbology::AltitudeSymbol>()->verticalOffset() = 0.1;
	}

	CGeoRectGrid::CGeoRectGrid(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoPoint(pRefMapNode)
	{
		this->mpNode = NULL;
		this->mType = "geoRingGrid";
		this->mWdith = 1000;
		this->mHeight = 1000;
		this->mRowCount = 4;
		this->mColCount = 4;
		Style& circleStyle = this->getStyle();
		circleStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		circleStyle.getOrCreate<LineSymbol>()->stroke()->width() = 3.0f;
		circleStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;// CLAMP_TO_TERRAIN;// ;
		circleStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;//DRAPE
		circleStyle.getOrCreate<osgEarth::Symbology::AltitudeSymbol>()->verticalOffset() = 0.1;
	}

	CGeoRectGrid::~CGeoRectGrid()
	{

	}

	void CGeoRectGrid::setWidth(const double& width)
	{
		this->mWdith = width;
	}

	double CGeoRectGrid::getWidth()
	{
		return this->mWdith;
	}

	void CGeoRectGrid::setHeight(const double& height)
	{
		this->mHeight = height;
	}

	double CGeoRectGrid::getHeight()
	{
		return this->mHeight;
	}

	void CGeoRectGrid::setRowCount(const int& rowCount)
	{
		this->mRowCount = rowCount;
	}

	int CGeoRectGrid::getRowCount()
	{
		return this->mRowCount;
	}

	void CGeoRectGrid::setColCount(const int& colCount)
	{
		this->mColCount = colCount;
	}

	int CGeoRectGrid::getColCount()
	{
		return this->mColCount;
	}

	bool CGeoRectGrid::loadToScene()
	{
		bool r = false;

		osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;

		osg::Vec4 color(1, 0, 0, 0.5);
		double width = 1;

		if (this->getStyle().get<osgEarth::Symbology::LineSymbol>())
		{
			color = this->getStyle().get<LineSymbol>()->stroke()->color();
			width = this->getStyle().get<LineSymbol>()->stroke()->width().get();
		}
		colors->push_back(color);
		osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
		std::vector<unsigned short> indices;
		osg::Vec3d leftDownPoint(-1.0 / 2, -1.0 / 2, 0);
		double rowInterval = 1.0 / this->getRowCount();
		double colInterval = 1.0 / this->getColCount();
		for (int rowIndex = 0; rowIndex < this->getRowCount(); ++rowIndex)
		{
			for (int colIndex = 0; colIndex < this->getColCount(); ++colIndex)
			{
				//第rowIndex行,第colIndex列的方格
				osg::Vec3d ldpoint = leftDownPoint + osg::Vec3d(1, 0, 0) * (colIndex * colInterval) + osg::Vec3d(0, 1, 0) * (rowIndex * rowInterval);
				osg::Vec3d rdpoint = leftDownPoint + osg::Vec3d(1, 0, 0) * ((colIndex + 1)* colInterval) + osg::Vec3d(0, 1, 0) * (rowIndex * rowInterval);
				osg::Vec3d lupoint = ldpoint + osg::Vec3d(0, 1, 0) * ((1)* rowInterval);
				osg::Vec3d rupoint = rdpoint + osg::Vec3d(0, 1, 0) * ((1) * rowInterval);

				//if (colIndex != 0)
				{
					indices.push_back(vertices->size());
					indices.push_back(vertices->size() + 1);
					vertices->push_back(ldpoint);
					vertices->push_back(lupoint);
				}
				
				//if (rowIndex != 0)
				{
					indices.push_back(vertices->size());
					indices.push_back(vertices->size() + 1);
					vertices->push_back(ldpoint);
					vertices->push_back(rdpoint);
				}

				//if (colIndex != this->getColCount() - 1)
				{
					indices.push_back(vertices->size());
					indices.push_back(vertices->size() + 1);
					vertices->push_back(rdpoint);
					vertices->push_back(rupoint);
				}

				//if (rowIndex != this->getRowCount() - 1)
				{
					indices.push_back(vertices->size());
					indices.push_back(vertices->size() + 1);
					vertices->push_back(rupoint);
					vertices->push_back(lupoint);
				}
			}
		}
		

		unsigned short* pIndices = new unsigned short[indices.size()];
		for (int i = 0; i < indices.size(); ++i)
		{
			pIndices[i] = indices[i];
		}
		int numIndices = sizeof(pIndices) / sizeof(unsigned short);
		numIndices = indices.size();
		osg::ref_ptr<osg::Geometry>geomTri = new osg::Geometry;
		geomTri->setColorArray(colors.get());
		geomTri->setVertexArray(vertices.get());
		geomTri->setColorBinding(osg::Geometry::BIND_OVERALL);

		geomTri->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
		osg::StateSet* stateset = new osg::StateSet;  //透明属性设置
		stateset->setMode(GL_BLEND, osg::StateAttribute::ON); //Alpha混合开启 
		stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::ON); //取消深度测试 
		stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF /*| osg::StateAttribute::PROTECTED*/);
		stateset->setAttribute(new osg::LineWidth(width), osg::StateAttribute::ON);
		stateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
		stateset->setRenderBinDetails(5, "RenderBin");

		osg::Geode* circle = new osg::Geode;//扇体节点
		geomTri->setStateSet(stateset);
		circle->addDrawable(geomTri.get());
		circle->addDescription(std::string("ringGrid"));

		osg::ref_ptr<osg::MatrixTransform> pRealCircle = new osg::MatrixTransform;
		pRealCircle->addChild(circle);

		osg::Matrixd worldMatrix;
		this->getMapNode()->getMap()->getSRS()->getEllipsoid()->computeLocalToWorldTransformFromLatLongHeight(
			osg::DegreesToRadians(this->getGeoPosition().y()),
			osg::DegreesToRadians(this->getGeoPosition().x()),
			this->getGeoPosition().z(), worldMatrix);
		pRealCircle->setMatrix(osg::Matrix::scale(this->getWidth(), this->getHeight(), 1) * worldMatrix);

		osg::LOD* pLod = new osg::LOD();
		pLod->addChild(pRealCircle, 0, 10000000000);
		this->mpNode = pLod;

		osg::ref_ptr<Common::IObject> userData = new Common::IObject();
		userData->setName(this->getName());
		userData->setID(this->getID());
		userData->setType(this->getType());
		this->mpNode->setUserData(userData);
		r = true;
		return r;
	}

	bool CGeoRectGrid::renderToScene()
	{
		bool r = false;
		if (this->mpNode && this->mpNode->getNumParents() == 0)
		{
			this->mpRefMapNode->addChild(this->mpNode);
			r = true;
		}
		return r;
	}

	bool CGeoRectGrid::deRenderFromScene()
	{
		return unLoadFromScene();
	}

	bool CGeoRectGrid::unLoadFromScene()
	{
		bool r = false;
		if (this->mpNode && this->mpNode->getNumParents() > 0)
		{
			this->mpNode->getParent(0)->removeChild(this->mpNode);
			this->mpNode = NULL;
			r = true;
		}
		return r;
	}

	osgEarth::Symbology::Style& CGeoRectGrid::getStyle()
	{
		return this->mStyle;
	}
}
