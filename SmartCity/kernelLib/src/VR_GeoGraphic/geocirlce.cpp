//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CGeoCircle.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geographic/geocirlce.h"
#include <osgEarthSymbology/GeometryFactory>
#include <osgEarth/GeoMath>
#include "geographic/geoline.h"
using namespace osgEarth::Symbology;


namespace Graphic
{
	CGeoCircle::CGeoCircle()
	{
		this->mType = Graphic::GT_CIRCLE;
		this->mRadius = 1000;
		this->mMaxGeometryPointNum = 2;
		this->mBeginAngle = 0;
		this->mEndAngle = 360;
		Style& geomStyle = this->getStyle();
		geomStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		geomStyle.getOrCreate<LineSymbol>()->stroke()->color().a() = 0.0;
	}

	CGeoCircle::CGeoCircle(osgEarth::MapNode* pRefMapNode)
		:CGeoPolygon(pRefMapNode)
	{
		this->mType = Graphic::GT_CIRCLE;
		this->mRadius = 10;
		this->mMaxGeometryPointNum = 2;
		this->mBeginAngle = 0;
		this->mEndAngle = 360;
		this->getStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
			->tessellation() = 1;
		//this->mpOutLine->get().getOrCreate<osgEarth::Symbology::LineSymbol>()
		//	->tessellation() = 1;
		if (this->mpOutLine)
		{
			this->mpOutLine->getStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->tessellation() = 1;
		}
	}

	CGeoCircle::~CGeoCircle()
	{
	
	}

	bool CGeoCircle::loadToScene()
	{
		bool r = false;
		if (this->mpLod)
			return r;
		std::vector<osg::Vec3d> renderGeometry;
		GeometryFactory factory = GeometryFactory(this->getMapNode()->getMapSRS()->getGeographicSRS());
		osgEarth::Symbology::Geometry* geometry = NULL;
		double segLen = this->getRadius() / 20;
        double circumference = 2 * osg::PI * this->getRadius();
        double numSegments = (unsigned)::ceil(circumference / segLen);
		if (std::abs(this->mEndAngle - this->mBeginAngle) >= 360.0)
		{
			geometry = factory.createCircle(this->getGeoPosition(), this->getRadius(), numSegments);
		}
		else
		{
			geometry = factory.createArc(this->getGeoPosition(), this->getRadius(),
				this->mBeginAngle, this->mEndAngle, numSegments, 0L, true);
		}

		for (int i = 0; i < geometry->size(); ++i)
		{
			renderGeometry.push_back(geometry->at(i));
		}
		delete geometry;
		geometry = NULL;
		return CGeoPolygon::loadToScene(renderGeometry);
	}
	
	void CGeoCircle::updateSceneObject()
	{
		if (this->mpLod == NULL)
		{
			this->loadToScene();
			this->renderToScene();
		}
		CGeoPolygon::updateSceneObject();
	}

	void CGeoCircle::setBeginAngle(const double& beginAngle)
	{
		this->mBeginAngle = beginAngle;
	}

	void CGeoCircle::setEndAngle(const double& endAngle)
	{
		this->mEndAngle = endAngle;
	}

	double CGeoCircle::getBeginAngle()
	{
		return this->mBeginAngle;
	}

	double CGeoCircle::getEndAngle()
	{
		return this->mEndAngle;
	}
	
	void CGeoCircle::copyTo(Common::ISceneObject* pDestObject)
	{
		CGeoPolygon::copyTo(pDestObject);
		CGeoCircle* pCircle = dynamic_cast<CGeoCircle*>(pDestObject);
		if (pCircle)
		{
			pCircle->setRadius(this->getRadius());
			pCircle->setBeginAngle(this->getBeginAngle());
			pCircle->setEndAngle(this->getEndAngle());
			pCircle->setGeoPosition(this->getGeoPosition());
		}
	}

	bool CGeoCircle::contain(const osg::Vec3d& geoPoint)
	{
		double distance = osgEarth::GeoMath::distance(
			this->getGeoPosition(),
			geoPoint, mpRefMapNode->getMap()->getSRS());
		return distance < this->getRadius();
	}

	std::vector<osg::Vec3d>& CGeoCircle::getGeometry()
	{
		if (CGeoPolygon::getGeometry().size() == 0
			&& this->getGeoPosition() != osg::Vec3d(0,0,0))
		{
			CGeoPolygon::getGeometry().push_back(this->getGeoPosition());
			GeometryFactory factory = GeometryFactory(this->getMapNode()->getMapSRS()->getGeographicSRS());
			osgEarth::Symbology::Geometry* geometry = NULL;
			if (std::abs(this->mEndAngle - this->mBeginAngle) >= 360.0)
			{
				geometry = factory.createCircle(this->getGeoPosition(), this->getRadius(), 0L);
			}
			else
			{
				geometry = factory.createArc(this->getGeoPosition(), this->getRadius(),
					this->mBeginAngle, this->mEndAngle, 0L, 0L, true);
			}
			if (geometry)
			{
				if (geometry->size() > 2)
				{
					CGeoPolygon::getGeometry().push_back(geometry->at(0));
				}
				delete geometry;
				geometry = NULL;
			}
		}
		return CGeoPolygon::getGeometry();
	}

	bool CGeoCircle::transformRenderGeometry(std::vector<osg::Vec3d>& outRenderGeometry)
	{
		bool r = false;
		double radius = this->getRadius();
		if (this->getGeometry().size() >= 2)
		{
			double radius =  osgEarth::GeoMath::distance(
				this->getGeometry().at(0), this->getGeometry().at(1), this->getMapNode()->getMapSRS());
			this->setGeoPosition(this->getGeometry().at(0));
			this->setRadius(radius);
		}
		else
		{
			radius = 0.0;
			osg::Vec3d geoPosition = (this->getGeometry().size() > 0) ? this->getGeometry().at(0) : osg::Vec3d(0,0,0);
			this->setGeoPosition(geoPosition);
			this->setRadius(radius);
		}
		GeometryFactory factory = GeometryFactory(this->getMapNode()->getMapSRS()->getGeographicSRS());
		osgEarth::Symbology::Geometry* geometry = NULL;
		if (std::abs(this->mEndAngle - this->mBeginAngle) >= 360.0)
		{
			geometry = factory.createCircle(this->getGeoPosition(), this->getRadius(), 0L);
		}
		else
		{
			geometry = factory.createArc(this->getGeoPosition(), this->getRadius(),
				this->mBeginAngle, this->mEndAngle, 0L, 0L, true);
		}
		for (int i = 0; i < geometry->size(); ++i)
		{
			outRenderGeometry.push_back(geometry->at(i));
		}
		delete geometry;
		geometry = NULL;
		r = true;
		return r;
	}

	void CGeoCircle::setRadius(const double& radius)
	{
		this->mRadius = radius;
	}

	double CGeoCircle::getRadius()
	{
		return this->mRadius;
	}
}

