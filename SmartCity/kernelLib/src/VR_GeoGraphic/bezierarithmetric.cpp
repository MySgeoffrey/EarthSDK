//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : cgeoarc.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geographic/bezierarithmetric.h"

namespace Graphic
{
	osg::Vec3d CBezierArithmetic::getBezierPointByRate(osg::Vec3d curvePoint[], float t)
	{
		osg::Vec3d newPoint;
		newPoint.x() = ((1 - t) * (1 - t) * curvePoint[0].x() + 2 * t * (1 - t) * curvePoint[1].x() + t * t * curvePoint[2].x());
		newPoint.y() = ((1 - t) * (1 - t) * curvePoint[0].y() + 2 * t * (1 - t) * curvePoint[1].y() + t * t * curvePoint[2].y());
		return newPoint;
	}

	void CBezierArithmetic::getBezierPointsLeft(
		osg::Vec3d bezierPoints[], std::vector<osg::Vec3d>& linePoints,
		const int& pointNum)
	{
		int rate = pointNum;
		double t, t1, t2, xt, yt;
		for (t = 0; t <= 1; t += 1.0 / rate)
		{
			yt = 1 - t;
			t1 = yt * yt;
			t2 = 3 * yt * t;
			xt = bezierPoints[0].x() * t1 * yt + bezierPoints[1].x() * t2 * yt + bezierPoints[2].x() * t2 * t + bezierPoints[3].x() * t * t * t;
			yt = bezierPoints[0].y() * t1 * yt + bezierPoints[1].y() * t2 * yt + bezierPoints[2].y() * t2 * t + bezierPoints[3].y() * t * t * t;
			linePoints.push_back(osg::Vec3d(xt, yt,0));
		}
	}

	void CBezierArithmetic::getBezierPointsRight(
		osg::Vec3d bezierPoints[], 
		std::vector<osg::Vec3d>& linePoints,
		const int& pointNum)
	{
		int rate = pointNum;
		double t, t1, t2, xt, yt;
		for (t = 1; t >= 0; t -= 1.0 / rate)
		{
			yt = 1 - t;
			t1 = yt * yt;
			t2 = 3 * yt * t;
			xt = bezierPoints[0].x() * t1 * yt + bezierPoints[1].x() * t2 * yt + bezierPoints[2].x() * t2 * t + bezierPoints[3].x() * t * t * t;
			yt = bezierPoints[0].y() * t1 * yt + bezierPoints[1].y() * t2 * yt + bezierPoints[2].y() * t2 * t + bezierPoints[3].y() * t * t * t;
			linePoints.push_back(osg::Vec3d(xt, yt,0));
		}
	}

	bool CBezierArithmetic::createBezierArrow(
		std::vector<osg::Vec3d>& originPoints,
		std::vector<osg::Vec3d>& results)
	{
		osg::Vec3d polyline[4];
		for (int i = 0; i < 4; ++i)
		{
			polyline[i] = originPoints.at(i);
		}
		osg::Vec3d curvePoint[4];
		curvePoint[0].x() = (polyline[0].x() + polyline[1].x()) / 2;
		curvePoint[0].y() = (polyline[0].y() + polyline[1].y()) / 2;

		osg::Vec3d pointsLeft[4];
		osg::Vec3d pointsRight[4];
		//左侧贝尔斯曲线起点
		pointsLeft[0] = polyline[0];
		//右侧贝尔斯曲线起点
		pointsRight[0] = polyline[1];

		curvePoint[1].x() = 2 * polyline[2].x() - 0.5 * (curvePoint[0].x() + polyline[3].x());
		curvePoint[1].y() = 2 * polyline[2].y() - 0.5 * (curvePoint[0].y() + polyline[3].y());
		curvePoint[2] = polyline[3];

		osg::Vec3d controlPoints[10];
		//生成箭头控制点
		controlPoints[0] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900000F);
		controlPoints[1] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900005F);
		controlPoints[2] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930000F);
		controlPoints[3] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930005F);
		controlPoints[4] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.999995F);
		controlPoints[5] = CBezierArithmetic::getBezierPointByRate(curvePoint, 1.000000F);
		controlPoints[6] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333333F);
		controlPoints[7] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333338F);
		controlPoints[8] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600000F);
		controlPoints[9] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600005F);

		double k1 = (controlPoints[1].y() - controlPoints[0].y()) / (controlPoints[1].x() - controlPoints[0].x());
		k1 = -(1 / k1);
		double b1 = controlPoints[0].y() - k1 * controlPoints[0].x();
		double k2 = (controlPoints[3].y() - controlPoints[2].y()) / (controlPoints[3].x() - controlPoints[2].x());
		k2 = -(1 / k2);
		double b2 = controlPoints[2].y() - k2 * controlPoints[2].x();
		double k3 = (controlPoints[5].y() - controlPoints[4].y()) / (controlPoints[5].x() - controlPoints[4].x());

		double angle1 = 30;
		double radians1 = angle1 * (3.1415926 / 180.0);
		double result1_d = std::tan(radians1);
		double result1 = (double)result1_d;

		//斜率为30度的两条直线
		double k31 = (k3 + result1) / (1 - k3 * result1);
		double b31 = controlPoints[5].y() - k31 * controlPoints[5].x();

		double k32 = (k3 - result1) / (1 + k3 * result1);
		double b32 = controlPoints[5].y() - k32 * controlPoints[5].x();

		double angle2 = 15;
		double radians2 = angle2 * (3.1415926 / 180.0);
		double result2_d = std::tan(radians2);
		double result2 = (double)result2_d;

		//斜率为15度的两条直线
		double k33 = (k3 + result2) / (1 - k3 * result2);
		double b33 = controlPoints[5].y() - k33 * controlPoints[5].x();

		double k34 = (k3 - result2) / (1 + k3 * result2);
		double b34 = controlPoints[5].y() - k34 * controlPoints[5].x();

		osg::Vec3d drawPoints[5];
		drawPoints[0].x() = (controlPoints[5].x());
		drawPoints[0].y() = (controlPoints[5].y());

		//30度夹角直线的交点
		drawPoints[1].x() = ((b31 - b1) / (k1 - k31));
		drawPoints[1].y() = ((b1 * k31 - b31 * k1) / (k31 - k1));

		drawPoints[2].x() = ((b32 - b1) / (k1 - k32));
		drawPoints[2].y() = ((b1 * k32 - b32 * k1) / (k32 - k1));

		//15度夹角直线的交点
		drawPoints[3].x() = ((b33 - b2) / (k2 - k33));
		drawPoints[3].y() = ((b2 * k33 - b33 * k2) / (k33 - k2));

		drawPoints[4].x() = ((b34 - b2) / (k2 - k34));
		drawPoints[4].y() = ((b2 * k34 - b34 * k2) / (k34 - k2));

		//添加贝尔斯曲线所需的点
		pointsLeft[3] = drawPoints[4];

		pointsRight[3] = drawPoints[3];

		pointsLeft[1] = curvePoint[1];
		pointsLeft[2] = pointsLeft[3];
		pointsRight[1] = curvePoint[1];
		pointsRight[2] = pointsRight[3];

		std::vector<osg::Vec3d> linePoints;

		//左侧曲线顶点
		CBezierArithmetic::getBezierPointsLeft(pointsLeft, linePoints);

		//箭头头部顶点
		linePoints.push_back(drawPoints[2]);
		linePoints.push_back(drawPoints[0]);
		linePoints.push_back(drawPoints[1]);

		//右侧曲线顶点
		CBezierArithmetic::getBezierPointsRight(pointsRight, linePoints);

		linePoints.push_back(pointsRight[0]);
		linePoints.push_back(linePoints.at(0));
		results = linePoints;
		return true;
	}

	bool CBezierArithmetic::createDirectArrow(
			std::vector<osg::Vec3d>& originPoints,
			std::vector<osg::Vec3d>& results)
	{
		osg::Vec3d polyline[4];
		polyline[0] = originPoints.at(0);
		polyline[1] = originPoints.at(1);
		polyline[2] = ((originPoints.at(1) + originPoints.at(0)) / 2 + originPoints.at(2)) / 2;
		polyline[3] = originPoints.at(2);
		
		osg::Vec3d curvePoint[4];
		curvePoint[0].x() = (polyline[0].x() + polyline[1].x()) / 2;
		curvePoint[0].y() = (polyline[0].y() + polyline[1].y()) / 2;

		osg::Vec3d pointsLeft[4];
		osg::Vec3d pointsRight[4];
		//左侧贝尔斯曲线起点
		pointsLeft[0] = polyline[0];
		//右侧贝尔斯曲线起点
		pointsRight[0] = polyline[1];

		curvePoint[1].x() = 2 * polyline[2].x() - 0.5 * (curvePoint[0].x() + polyline[3].x());
		curvePoint[1].y() = 2 * polyline[2].y() - 0.5 * (curvePoint[0].y() + polyline[3].y());
		curvePoint[2] = polyline[3];

		osg::Vec3d controlPoints[10];
		//生成箭头控制点
		controlPoints[0] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900000F);
		controlPoints[1] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900005F);
		controlPoints[2] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930000F);
		controlPoints[3] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930005F);
		controlPoints[4] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.999995F);
		controlPoints[5] = CBezierArithmetic::getBezierPointByRate(curvePoint, 1.000000F);
		controlPoints[6] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333333F);
		controlPoints[7] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333338F);
		controlPoints[8] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600000F);
		controlPoints[9] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600005F);

		double k1 = (controlPoints[1].y() - controlPoints[0].y()) / (controlPoints[1].x() - controlPoints[0].x());
		k1 = -(1 / k1);
		double b1 = controlPoints[0].y() - k1 * controlPoints[0].x();
		double k2 = (controlPoints[3].y() - controlPoints[2].y()) / (controlPoints[3].x() - controlPoints[2].x());
		k2 = -(1 / k2);
		double b2 = controlPoints[2].y() - k2 * controlPoints[2].x();
		double k3 = (controlPoints[5].y() - controlPoints[4].y()) / (controlPoints[5].x() - controlPoints[4].x());

		double angle1 = 30;
		double radians1 = angle1 * (3.1415926 / 180.0);
		double result1_d = std::tan(radians1);
		double result1 = (double)result1_d;

		//斜率为30度的两条直线
		double k31 = (k3 + result1) / (1 - k3 * result1);
		double b31 = controlPoints[5].y() - k31 * controlPoints[5].x();

		double k32 = (k3 - result1) / (1 + k3 * result1);
		double b32 = controlPoints[5].y() - k32 * controlPoints[5].x();

		double angle2 = 15;
		double radians2 = angle2 * (3.1415926 / 180.0);
		double result2_d = std::tan(radians2);
		double result2 = (double)result2_d;

		//斜率为15度的两条直线
		double k33 = (k3 + result2) / (1 - k3 * result2);
		double b33 = controlPoints[5].y() - k33 * controlPoints[5].x();

		double k34 = (k3 - result2) / (1 + k3 * result2);
		double b34 = controlPoints[5].y() - k34 * controlPoints[5].x();

		osg::Vec3d drawPoints[5];
		drawPoints[0].x() = (controlPoints[5].x());
		drawPoints[0].y() = (controlPoints[5].y());

		//30度夹角直线的交点
		drawPoints[1].x() = ((b31 - b1) / (k1 - k31));
		drawPoints[1].y() = ((b1 * k31 - b31 * k1) / (k31 - k1));

		drawPoints[2].x() = ((b32 - b1) / (k1 - k32));
		drawPoints[2].y() = ((b1 * k32 - b32 * k1) / (k32 - k1));

		//15度夹角直线的交点
		drawPoints[3].x() = ((b33 - b2) / (k2 - k33));
		drawPoints[3].y() = ((b2 * k33 - b33 * k2) / (k33 - k2));

		drawPoints[4].x() = ((b34 - b2) / (k2 - k34));
		drawPoints[4].y() = ((b2 * k34 - b34 * k2) / (k34 - k2));

		//添加贝尔斯曲线所需的点
		pointsLeft[3] = drawPoints[4];

		pointsRight[3] = drawPoints[3];

		pointsLeft[1] = curvePoint[1];
		pointsLeft[2] = pointsLeft[3];
		pointsRight[1] = curvePoint[1];
		pointsRight[2] = pointsRight[3];

		std::vector<osg::Vec3d> linePoints;

		//左侧曲线顶点
		CBezierArithmetic::getBezierPointsLeft(pointsLeft, linePoints,1);

		//箭头头部顶点
		linePoints.push_back(drawPoints[2]);
		linePoints.push_back(drawPoints[0]);
		linePoints.push_back(drawPoints[1]);

		//右侧曲线顶点
		CBezierArithmetic::getBezierPointsRight(pointsRight, linePoints,1);

		linePoints.push_back(pointsRight[0]);
		linePoints.push_back(linePoints.at(0));
		results = linePoints;
		return true;
	}

	bool CBezierArithmetic::createDoubleArrow(
			std::vector<osg::Vec3d>& originPoints,
			std::vector<osg::Vec3d>& results)
	{
		osg::Vec3d polyline[4];
		for (int i = 0; i < 4; ++i)
		{
			polyline[i] = originPoints.at(i);
		}
		osg::Vec3d curvePoint[4];
		curvePoint[0].x() = (polyline[0].x() + polyline[1].x()) / 2;
		curvePoint[0].y() = (polyline[0].y() + polyline[1].y()) / 2;

		osg::Vec3d pointsLeft[4];
		osg::Vec3d pointsRight[4];
		//左侧贝尔斯曲线起点
		pointsLeft[0] = polyline[0];
		//右侧贝尔斯曲线起点
		pointsRight[0] = polyline[1];

		curvePoint[1].x() = 2 * polyline[2].x() - 0.5 * (curvePoint[0].x() + polyline[3].x());
		curvePoint[1].y() = 2 * polyline[2].y() - 0.5 * (curvePoint[0].y() + polyline[3].y());
		curvePoint[2] = polyline[3];

		osg::Vec3d controlPoints[10];
		//生成箭头控制点
		controlPoints[0] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900000F);
		controlPoints[1] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.900005F);
		controlPoints[2] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930000F);
		controlPoints[3] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.930005F);
		controlPoints[4] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.999995F);
		controlPoints[5] = CBezierArithmetic::getBezierPointByRate(curvePoint, 1.000000F);
		controlPoints[6] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333333F);
		controlPoints[7] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.333338F);
		controlPoints[8] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600000F);
		controlPoints[9] = CBezierArithmetic::getBezierPointByRate(curvePoint, 0.600005F);

		double k1 = (controlPoints[1].y() - controlPoints[0].y()) / (controlPoints[1].x() - controlPoints[0].x());
		k1 = -(1 / k1);
		double b1 = controlPoints[0].y() - k1 * controlPoints[0].x();
		double k2 = (controlPoints[3].y() - controlPoints[2].y()) / (controlPoints[3].x() - controlPoints[2].x());
		k2 = -(1 / k2);
		double b2 = controlPoints[2].y() - k2 * controlPoints[2].x();
		double k3 = (controlPoints[5].y() - controlPoints[4].y()) / (controlPoints[5].x() - controlPoints[4].x());

		double angle1 = 30;
		double radians1 = angle1 * (3.1415926 / 180.0);
		double result1_d = std::tan(radians1);
		double result1 = (double)result1_d;

		//斜率为30度的两条直线
		double k31 = (k3 + result1) / (1 - k3 * result1);
		double b31 = controlPoints[5].y() - k31 * controlPoints[5].x();

		double k32 = (k3 - result1) / (1 + k3 * result1);
		double b32 = controlPoints[5].y() - k32 * controlPoints[5].x();

		double angle2 = 15;
		double radians2 = angle2 * (3.1415926 / 180.0);
		double result2_d = std::tan(radians2);
		double result2 = (double)result2_d;

		//斜率为15度的两条直线
		double k33 = (k3 + result2) / (1 - k3 * result2);
		double b33 = controlPoints[5].y() - k33 * controlPoints[5].x();

		double k34 = (k3 - result2) / (1 + k3 * result2);
		double b34 = controlPoints[5].y() - k34 * controlPoints[5].x();

		osg::Vec3d drawPoints[5];
		drawPoints[0].x() = (controlPoints[5].x());
		drawPoints[0].y() = (controlPoints[5].y());

		//30度夹角直线的交点
		drawPoints[1].x() = ((b31 - b1) / (k1 - k31));
		drawPoints[1].y() = ((b1 * k31 - b31 * k1) / (k31 - k1));

		drawPoints[2].x() = ((b32 - b1) / (k1 - k32));
		drawPoints[2].y() = ((b1 * k32 - b32 * k1) / (k32 - k1));

		//15度夹角直线的交点
		drawPoints[3].x() = ((b33 - b2) / (k2 - k33));
		drawPoints[3].y() = ((b2 * k33 - b33 * k2) / (k33 - k2));

		drawPoints[4].x() = ((b34 - b2) / (k2 - k34));
		drawPoints[4].y() = ((b2 * k34 - b34 * k2) / (k34 - k2));

		//添加贝尔斯曲线所需的点
		pointsLeft[3] = drawPoints[4];

		pointsRight[3] = drawPoints[3];

		pointsLeft[1] = curvePoint[1];
		pointsLeft[2] = pointsLeft[3];
		pointsRight[1] = curvePoint[1];
		pointsRight[2] = pointsRight[3];

		std::vector<osg::Vec3d> linePoints;

		//左侧曲线顶点
		CBezierArithmetic::getBezierPointsLeft(pointsLeft, linePoints);

		//箭头头部顶点
		linePoints.push_back(drawPoints[2]);
		linePoints.push_back(drawPoints[0]);
		linePoints.push_back(drawPoints[1]);

		//右侧曲线顶点
		CBezierArithmetic::getBezierPointsRight(pointsRight, linePoints);

		linePoints.push_back(pointsRight[0]);
		linePoints.push_back(linePoints.at(0));
		results = linePoints;
		return true;
	}

	void CBezierArithmetic::binomialCoefficient(std::vector<int> &C)
	{
		int j,n=C.size() - 1;
		for(int k=0;k<=n;k++){
			C[k] = 1;
			for(j=n;j>k;j--)
				C[k] *= j;//分子累乘
			for(j=n-k;j>1;j--)
				C[k] /= j;//分母累除
		}
	}

	void CBezierArithmetic::computeBezPt(float u,osg::Vec3d &bezPt,std::vector<osg::Vec3d>&ctrlPts,std::vector<int> &C)
	{
		int n=ctrlPts.size() - 1;
		float bezFcn;//保存贝塞尔方程计算结果
		bezPt.x() = bezPt.y() = bezPt.z() = 0;//初始化
		for(int k=0;k<=n;k++){
			bezFcn = C[k]*pow(u,k)*pow(1-u,n-k);
			bezPt.x() +=ctrlPts[k].x() * bezFcn;
			bezPt.y() +=ctrlPts[k].y() * bezFcn;
			bezPt.z() +=ctrlPts[k].z() * bezFcn;
		}
	}

	void CBezierArithmetic::bezierLine(
		std::vector<osg::Vec3d>& ctrlPts,
		std::vector<osg::Vec3d>& bezPts,
		int precision)
	{
		std::vector<int> C;
		C.resize(ctrlPts.size());
		binomialCoefficient(C);//计算系数

		//保存计算点的参数
		bezPts.resize(precision+1);

		float u;//规律参数
		for(int k=0;k<=precision;k++){
			u = float(k)/float(precision);
			computeBezPt(u,bezPts[k],ctrlPts,C);
		}
	}
}
