//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : CGeoRectangle.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geographic/rectangle.h"
#include <osgEarthSymbology/GeometryFactory>
#include <osgEarth/GeoMath>

using namespace osgEarth::Symbology;


namespace Graphic
{
	CGeoRectangle::CGeoRectangle()
	{
		this->mType = Graphic::GT_RECTANGLE;
		this->mMaxGeometryPointNum = 2;
	}

	CGeoRectangle::CGeoRectangle(osgEarth::MapNode* pRefMapNode)
		:CGeoPolygon(pRefMapNode)
	{
		this->mType = Graphic::GT_RECTANGLE;
		this->mMaxGeometryPointNum = 2;
		this->mWidth = 600;
		this->mLength = 1000;
	}

	CGeoRectangle::~CGeoRectangle()
	{
		this->mWidth = 600;
		this->mLength = 1000;
	}

	void CGeoRectangle::copyTo(Common::ISceneObject* pDestObject)
	{
		CGeoPolygon::copyTo(pDestObject);
		CGeoRectangle* pRect = dynamic_cast<CGeoRectangle*>(pDestObject);
		if (pRect)
		{
			pRect->setWidth(this->getWidth());
			pRect->setLength(this->getLength());
		}
	}
	
	void CGeoRectangle::updateSceneObject()
	{
		if (this->mpLod == NULL)
		{
			this->loadToScene();
			this->renderToScene();
		}
		CGeoPolygon::updateSceneObject();
	}

	void CGeoRectangle::setWidth(const double& width)
	{
		this->mWidth = width;
	}

	double CGeoRectangle::getWidth()
	{
		return this->mWidth;
	}

	void CGeoRectangle::setLength(const double& length)
	{
		this->mLength = length;
	}

	double CGeoRectangle::getLength()
	{
		return this->mLength;
	}
	
	bool CGeoRectangle::transformRenderGeometry(std::vector<osg::Vec3d>& outRenderGeometry)
	{
		bool r = false;
		double width = this->getWidth();
		double length = this->getLength();
		if (this->getGeometry().size() >= 2)
		{
			osg::Vec3d firstPos = this->getGeometry().at(0);
			osg::Vec3d secondPos = this->getGeometry().at(1);
			double minLon = std::min(firstPos.x(),secondPos.x());
			double minLat = std::min(firstPos.y(),secondPos.y());

			double maxLon = std::max(firstPos.x(),secondPos.x());
			double maxLat = std::max(firstPos.y(),secondPos.y());

			osg::Vec3d center((minLon + maxLon) / 2 ,(minLat + maxLat) / 2 ,0);
			osg::Vec3d upLeft(minLon,maxLat,0);
			osg::Vec3d upRight(maxLon,maxLat,0);
			osg::Vec3d downLeft(minLon,minLat,0);
			this->setGeoPosition(center);
			length =  osgEarth::GeoMath::distance(
				upLeft, upRight, this->getMapNode()->getMapSRS());
			width =  osgEarth::GeoMath::distance(
				upLeft, downLeft, this->getMapNode()->getMapSRS());
		}
		GeometryFactory factory = GeometryFactory(this->getMapNode()->getMapSRS()->getGeographicSRS());
		osgEarth::Symbology::Geometry* geometry = factory.createRectangle(this->getGeoPosition(),
			osgEarth::Distance(length),osgEarth::Distance(width));
		for (int i = 0; i < geometry->size(); ++i)
		{
			outRenderGeometry.push_back(geometry->at(i));
		}
		delete geometry;
		geometry = NULL;
		r = true;
		return r;
	}
}

