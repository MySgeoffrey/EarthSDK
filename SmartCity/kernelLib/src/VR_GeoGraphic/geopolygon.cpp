//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : cgeopolygon.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geographic/geopolygon.h"
#include <osgEarthSymbology/Geometry>
#include <osgEarthFeatures/Feature>
#include <osgEarthAnnotation/FeatureNode>
#include <osgEarth/Registry>
#include "geographic/geoline.h"

using namespace Core;
using namespace osgEarth::Symbology;

#define _USE_CUSTOM_OUTLINE_ 1

namespace Graphic
{
	CGeoSurface::CGeoSurface()
	{

	}

	CGeoSurface::~CGeoSurface()
	{

	}

	osg::Node* CGeoSurface::createNode(
		std::vector<osg::Vec3d>& renderGeometry,
		osgEarth::Symbology::Style& renderStyle,
		osgEarth::MapNode* pMapNode)
	{
		osgEarth::Annotation::FeatureNode* pathNode = NULL;
		{
			osgEarth::Symbology::Geometry* path = new osgEarth::Symbology::Polygon();
			for (int i = 0; i < renderGeometry.size(); ++i)
			{
				osg::Vec3d& point = renderGeometry.at(i);
				path->push_back(point);
			}
#if _USE_CUSTOM_OUTLINE_
			osgEarth::Symbology::Style tempRenderStyle = renderStyle;
			tempRenderStyle.getOrCreateSymbol<osgEarth::LineSymbol>()->stroke()->color() = osgEarth::Symbology::Color(1.0,0.0,0.0,0.0);
			osgEarth::Features::Feature* pathFeature = new osgEarth::Features::Feature(
				path, pMapNode->getMapSRS(), tempRenderStyle);
#else
			osgEarth::Features::Feature* pathFeature = new osgEarth::Features::Feature(
				path, pMapNode->getMapSRS(), renderStyle);
#endif
			pathFeature->geoInterp() = GEOINTERP_GREAT_CIRCLE;
			pathNode = new osgEarth::Annotation::FeatureNode(pMapNode, pathFeature,
				renderStyle, osgEarth::Features::GeometryCompilerOptions());
		}
		return pathNode;
	}

	CGeoPolygon::CGeoPolygon()
	{
		this->mpNode = NULL;
		this->mType = Graphic::GT_POLYGON;
		Style& geomStyle = this->getStyle();
		geomStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		geomStyle.getOrCreate<LineSymbol>()->stroke()->width() = 5.0f;
		geomStyle.getOrCreate<osgEarth::Symbology::PolygonSymbol>()->fill()->color() =
			osgEarth::Symbology::Color(osgEarth::Symbology::Color::Blue, 0.5);
		geomStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;
		geomStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;
		RenderSymbol* rs = geomStyle.getOrCreateSymbol<RenderSymbol>();
		rs->depthOffset()->enabled() = true;
		rs->depthOffset()->minBias() = 1000;
	}

	CGeoPolygon::CGeoPolygon(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoPolygon(pRefMapNode)
	{
		this->mpNode = NULL;
		this->mType = Graphic::GT_POLYGON;
		Style& geomStyle = this->getStyle();
		geomStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		geomStyle.getOrCreate<LineSymbol>()->stroke()->width() = 5.0f;
		geomStyle.getOrCreate<osgEarth::Symbology::PolygonSymbol>()->fill()->color() =
			osgEarth::Symbology::Color(osgEarth::Symbology::Color::Blue, 0.5);
		geomStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;
		geomStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;	
		this->mpOutLine = NULL;
#if _USE_CUSTOM_OUTLINE_
		this->mpOutLine = new CGeoLine(pRefMapNode);
#endif
	}

	CGeoPolygon::~CGeoPolygon()
	{
	
	}

	bool CGeoPolygon::loadToScene()
	{
		bool r = false;
		if (this->mpLod)
			return r;

		std::vector<osg::Vec3d> renderGeometry;
		this->transformRenderGeometry(renderGeometry);
		return this->loadToScene(renderGeometry);
	}

	bool CGeoPolygon::renderToScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() == 0)
		{
			this->mpRefMapNode->addChild(this->mpLod);
#if _USE_CUSTOM_OUTLINE_
			this->mpOutLine->renderToScene();
#endif
			r = true;
		}
		return r;
	}

	bool CGeoPolygon::deRenderFromScene()
	{
		return false;
	}

	bool CGeoPolygon::unLoadFromScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() > 0)
		{
			this->mpLod->getParent(0)->removeChild(this->mpLod);
			this->mpLod = NULL;
#if _USE_CUSTOM_OUTLINE_
			this->mpOutLine->unLoadFromScene();
#endif
			r = true;
		}
		return r;
	}

	void CGeoPolygon::updateSceneObject()
	{
		if (this->mpLod == NULL)
		{
			this->loadToScene();
			this->renderToScene();
		}
		if (this->mpLod)
		{
			std::vector<osg::Vec3d> renderGeometry;
			this->transformRenderGeometry(renderGeometry);
			{
				osgEarth::Annotation::FeatureNode* pathNode = 
					dynamic_cast<osgEarth::Annotation::FeatureNode*>(this->mpLod->getChild(0));
				if (pathNode)
				{
					osgEarth::Symbology::Geometry* path = pathNode->getFeature()->getGeometry();
					path->clear();
					for (int i = 0; i < renderGeometry.size(); ++i)
					{
						osg::Vec3d& point = renderGeometry.at(i);
						path->push_back(point);
					}
					pathNode->init();
				}
#if _USE_CUSTOM_OUTLINE_
				this->mpOutLine->getGeometry().clear();
				if (renderGeometry.size() > 0)
				{
					this->mpOutLine->getGeometry().insert(
						this->mpOutLine->getGeometry().begin(),
						renderGeometry.begin(),renderGeometry.end());
					this->mpOutLine->getGeometry().push_back(renderGeometry.at(0));
				}
				this->mpOutLine->updateSceneObject();
#endif
			}
		}
	}

	void CGeoPolygon::copyTo(Common::ISceneObject* pDestObject)
	{
		Common::ISceneObject::copyTo(pDestObject);
	}

	bool CGeoPolygon::transformRenderGeometry(std::vector<osg::Vec3d>& outRenderGeometry)
	{
		outRenderGeometry = this->getGeometry();
		return outRenderGeometry.size() >= 3;
	}

	bool CGeoPolygon::loadToScene(std::vector<osg::Vec3d>& renderGeometry)
	{
		bool r = false;
		{
#if _USE_CUSTOM_OUTLINE_
			if (renderGeometry.size() > 0)
			{
				this->mpOutLine->getGeometry().clear();
				this->mpOutLine->getGeometry().insert(
				this->mpOutLine->getGeometry().begin(),
				renderGeometry.begin(),renderGeometry.end());
				this->mpOutLine->getGeometry().push_back(renderGeometry.at(0));
			}
			this->mpOutLine->getStyle().getOrCreateSymbol<osgEarth::LineSymbol>()->stroke()->color() = 
				this->getStyle().getOrCreateSymbol<osgEarth::LineSymbol>()->stroke()->color();
			this->mpOutLine->getStyle().getOrCreateSymbol<osgEarth::LineSymbol>()->stroke()->width() = 
				this->getStyle().getOrCreateSymbol<osgEarth::LineSymbol>()->stroke()->width();
			this->mpOutLine->loadToScene();
#endif
			osg::Node* pathNode = this->createNode(
				renderGeometry,
				this->getStyle(),
				this->getMapNode());
			this->mObjectId = osgEarth::Registry::objectIndex()->tagNode(pathNode, this);
 			if (NULL == this->mpLod)
			{
				this->mpLod = new osg::LOD();
			}
			this->mpLod->addChild(pathNode, 0, 10000000000);
			r = true;
		}
		return r;
	}


	CGeoTriangle::CGeoTriangle()
	{
		this->mType = Graphic::GT_TRIANGLE;
		this->mMaxGeometryPointNum = 3;
	}

	CGeoTriangle::CGeoTriangle(osgEarth::MapNode* pRefMapNode)
		: CGeoPolygon(pRefMapNode)
	{
		this->mType = Graphic::GT_TRIANGLE;
		this->mMaxGeometryPointNum = 3;
	}

	CGeoTriangle::~CGeoTriangle()
	{
	
	}
}

