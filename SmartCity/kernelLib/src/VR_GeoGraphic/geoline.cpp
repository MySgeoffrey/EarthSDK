//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 蚂蚁空间信息平台
//  @ File Name : igeoline.cpp
//  @ Date : 2017/8/21
//  @ Author : 
//
//


#include "geographic/geoline.h"
#include <osg/Geometry>
#include <osgEarthSymbology/Geometry>
#include <osgEarthFeatures/Feature>
#include <osgEarthAnnotation/FeatureNode>
#include <osgEarth/Registry>
#include <osg/LineWidth>
#include "geographic/geographictype.h"
#include <osgEarthFeatures/TessellateOperator>

using namespace osg;
using namespace osgEarth;
using namespace osgEarth::Symbology;

void tessellateGeo( 
	const osg::Vec3d& p0, 
	const osg::Vec3d& p1, 
	unsigned parts, 
	GeoInterpolation interp, 
	Vec3dVector& out )
{
    double step = 1.0/double(parts);
    double zdelta = p1.z() - p0.z();

    out.push_back( p0 );

    for( unsigned i=1; i<parts; ++i )
    {
        double t = step*double(i);
        osg::Vec3d p;

        if ( interp == GEOINTERP_GREAT_CIRCLE )
        {
            double lat, lon;
            GeoMath::interpolate(
                osg::DegreesToRadians(p0.y()), osg::DegreesToRadians(p0.x()),
                osg::DegreesToRadians(p1.y()), osg::DegreesToRadians(p1.x()),
                t,
                lat, lon );
            p.set( osg::RadiansToDegrees(lon), osg::RadiansToDegrees(lat), p0.z() + t*zdelta );
        }
        else // GEOINTERP_RHUMB_LINE
        {
            double lat1 = osg::DegreesToRadians(p0.y()), lon1 = osg::DegreesToRadians(p0.x());
            double lat2 = osg::DegreesToRadians(p1.y()), lon2 = osg::DegreesToRadians(p1.x());

            double totalDistance = GeoMath::rhumbDistance( lat1, lon1, lat2, lon2 );
            double bearing  = GeoMath::rhumbBearing( lat1, lon1, lat2, lon2 );

            double interpDistance = t * totalDistance;

            double lat3, lon3;
            GeoMath::rhumbDestination(lat1, lon1, bearing, interpDistance, lat3, lon3);

            p.set( osg::RadiansToDegrees(lon3), osg::RadiansToDegrees(lat3), p0.z() + t*zdelta );
        }

        out.push_back(p);
    }
}

namespace Graphic
{
	CGeoLine::CGeoLine()
	{
		this->mpNode = NULL;
		this->mType = Graphic::GT_POLYLINE;
		Style& pathStyle = this->getStyle();
		pathStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		pathStyle.getOrCreate<LineSymbol>()->stroke()->width() = 5.0f;
		pathStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;
		pathStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;
		pathStyle.getOrCreate<AltitudeSymbol>()->verticalOffset() = 1;
		pathStyle.getOrCreate<LineSymbol>()->tessellation() = 20;
		this->mUseCustomRenderMode = false;
	}

	CGeoLine::CGeoLine(osgEarth::MapNode* pRefMapNode)
		: Core::IGeoLine(pRefMapNode)
	{
		this->mpNode = NULL;
		this->mType = Graphic::GT_POLYLINE;
		Style& pathStyle = this->getStyle();
		pathStyle.getOrCreate<LineSymbol>()->stroke()->color() = Color::Red;
		pathStyle.getOrCreate<LineSymbol>()->stroke()->width() = 5.0f;
		pathStyle.getOrCreate<AltitudeSymbol>()->clamping() = AltitudeSymbol::CLAMP_TO_TERRAIN;
		pathStyle.getOrCreate<AltitudeSymbol>()->technique() = AltitudeSymbol::TECHNIQUE_DRAPE;
		pathStyle.getOrCreate<AltitudeSymbol>()->verticalOffset() = 1;
		pathStyle.getOrCreate<LineSymbol>()->tessellation() = 20;
		this->mUseCustomRenderMode = true;
	}

	CGeoLine::~CGeoLine()
	{
		this->mpNode = NULL;
	}

	bool CGeoLine::loadToScene()
	{
		bool r = false;
		if (this->mpLod)
			return r;

		std::vector<osg::Vec3d> renderGeometry;
		this->transformRenderGeometry(renderGeometry);
		return this->loadToScene(renderGeometry);
	}

	bool CGeoLine::renderToScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() == 0)
		{
			this->mpRefMapNode->addChild(this->mpLod);
			r = true;
		}
		return r;
	}

	bool CGeoLine::deRenderFromScene()
	{
		bool r = false;

		return r;
	}

	bool CGeoLine::unLoadFromScene()
	{
		bool r = false;
		if (this->mpLod && this->mpLod->getNumParents() > 0)
		{
			this->mpLod->getParent(0)->removeChild(this->mpLod);
			this->mpLod = NULL;
			this->mpNode = NULL;
			r = true;
		}
		return r;
	}

	void CGeoLine::updateSceneObject()
	{
		if (this->mpLod == NULL)
		{
			this->loadToScene();
			this->renderToScene();
		}
		if (this->mpLod)
		{
			std::vector<osg::Vec3d> renderGeometry;
			this->transformRenderGeometry(renderGeometry);
			if (this->getUseCustomRenderMode())
			{
				osg::MatrixTransform* pathNode = 
					dynamic_cast<osg::MatrixTransform*>(this->mpLod->getChild(0));
				if (pathNode)
				{
					osgEarth::Symbology::Color color = this->getStyle().getOrCreate<LineSymbol>()->stroke()->color();
					float width = this->getStyle().getOrCreate<LineSymbol>()->stroke()->width().get();

					osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
					colors->push_back(color);
					osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
					std::vector<unsigned short> indices;
					std::vector<osg::Vec3d> worldGeometry;
					osg::Vec3d referenceCenter(0,0,0);
					this->computeRenderGeometry(
						renderGeometry,
						worldGeometry,
						referenceCenter);
					for (int i = 0 ; i < worldGeometry.size(); ++i)
					{
						osg::Vec3d relativePoint = worldGeometry[i] - referenceCenter;
						vertices->push_back(relativePoint);
						if (i < worldGeometry.size() - 1)
						{
							indices.push_back(i);
							indices.push_back(i+1);
						}
					}

					unsigned short* pIndices = new unsigned short[indices.size()];
					for (int i = 0; i < indices.size(); ++i)
					{
						pIndices[i] = indices[i];
					}
					int numIndices = sizeof(pIndices) / sizeof(unsigned short);
					numIndices = indices.size();
					osg::ref_ptr<osg::Geometry> pGeometry = new osg::Geometry;
					pGeometry->setColorArray(colors.get());
					pGeometry->setVertexArray(vertices.get());
					pGeometry->setColorBinding(osg::Geometry::BIND_OVERALL);

					pGeometry->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
					osg::StateSet* stateset = new osg::StateSet;  //透明属性设置
					stateset->setMode(GL_BLEND, osg::StateAttribute::ON); //Alpha混合开启 
					stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF); //取消深度测试 
					stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF /*| osg::StateAttribute::PROTECTED*/);
					stateset->setAttributeAndModes(new osg::LineWidth(width), osg::StateAttribute::ON);
					stateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
					stateset->setRenderBinDetails(5, "RenderBin");

					osg::Geode* pSegment = new osg::Geode;//扇体节点
					pGeometry->setStateSet(stateset);
					pSegment->addDrawable(pGeometry.get());
					pathNode->removeChild(0,1);
					pathNode->addChild(pSegment);
					pathNode->setMatrix(osg::Matrix::translate(referenceCenter));
					/*osg::Geode* pSegment = dynamic_cast<osg::Geode*>(pathNode->getChild(0));
					osg::ref_ptr<osg::Geometry> pGeometry =
						dynamic_cast<osg::Geometry*>(pSegment->getDrawable(0));
					if (pGeometry)
					{
						osgEarth::Symbology::Color color = this->getStyle().getOrCreate<LineSymbol>()->stroke()->color();
						float width = this->getStyle().getOrCreate<LineSymbol>()->stroke()->width().get();

						osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
						colors->push_back(color);
						osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
						std::vector<unsigned short> indices;
						std::vector<osg::Vec3d> worldGeometry;
						osg::Vec3d referenceCenter(0,0,0);
						this->computeRenderGeometry(
							renderGeometry,
							worldGeometry,
							referenceCenter);
						for (int i = 0 ; i < worldGeometry.size(); ++i)
						{
							osg::Vec3d relativePoint = worldGeometry[i] - referenceCenter;
							vertices->push_back(relativePoint);
							if (i < worldGeometry.size() - 1)
							{
								indices.push_back(i);
								indices.push_back(i+1);
							}
						}

						unsigned short* pIndices = new unsigned short[indices.size()];
						for (int i = 0; i < indices.size(); ++i)
						{
							pIndices[i] = indices[i];
						}
						int numIndices = sizeof(pIndices) / sizeof(unsigned short);
						numIndices = indices.size();
						osg::ref_ptr<osg::Geometry> pGeometry = new osg::Geometry;
						pGeometry->setColorArray(colors.get());
						pGeometry->setVertexArray(vertices.get());
						pGeometry->setColorBinding(osg::Geometry::BIND_OVERALL);

						pGeometry->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
						pathNode->setMatrix(osg::Matrix::translate(referenceCenter));
					}*/
				}
			}
			else
			{
				osgEarth::Annotation::FeatureNode* pathNode = 
					dynamic_cast<osgEarth::Annotation::FeatureNode*>(this->mpLod->getChild(0));
				if (pathNode)
				{
					osgEarth::Symbology::Geometry* path = pathNode->getFeature()->getGeometry();
					path->clear();
					for (int i = 0; i < renderGeometry.size(); ++i)
					{
						osg::Vec3d& point = renderGeometry.at(i);
						path->push_back(point);
					}
					osg::Vec3d geoPosition = path->at(0);
					this->setGeoPosition(geoPosition);
					pathNode->init();
				}
			}
		}
	}

	void CGeoLine::setUseCustomRenderMode(const bool& value)
	{
		this->mUseCustomRenderMode = value;
	}

	bool CGeoLine::getUseCustomRenderMode()
	{
		return this->mUseCustomRenderMode;
	}

	void CGeoLine::computeRenderGeometry(
			std::vector<osg::Vec3d>& inRenderGeometry,
			std::vector<osg::Vec3d>& outRenderGeometry,
			osg::Vec3d& referenceCenter)
	{
		if (inRenderGeometry.size() > 0)
		{
			unsigned int parts = this->getStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->tessellation().get();
			bool needInterpolate = (parts != 1);
			if (needInterpolate)
			{
				double depthOffset = this->getStyle().getOrCreate<osgEarth::Symbology::AltitudeSymbol>()
							->verticalOffset().value().eval();

				for (int i = 0; i < inRenderGeometry.size() - 1; ++i)
				{
					osg::Vec3d fromGeoPosition = inRenderGeometry.at(i);
					osg::Vec3d toGeoPosition = inRenderGeometry.at(i+1);
					Vec3dVector out;
					tessellateGeo(fromGeoPosition,toGeoPosition,
						parts,osgEarth::GEOINTERP_GREAT_CIRCLE,out);
					out.push_back(toGeoPosition);
					for (int k = 0; k < out.size(); ++k)
					{
						osg::Vec3d originPosition = out.at(k);
						originPosition.z() = originPosition.z() + depthOffset;
						osgEarth::GeoPoint geoPosition(
							this->getMapNode()->getMapSRS(),
							originPosition);

						osg::Vec3d worldPoint;
						geoPosition.toWorld(worldPoint);
						outRenderGeometry.push_back(worldPoint);
						referenceCenter += worldPoint;	
					}
				}
				referenceCenter /= outRenderGeometry.size();
			}
			else
			{
				for (int i = 0; i < inRenderGeometry.size(); ++i)
				{
					/*this->getStyle().getOrCreate<osgEarth::Symbology::AltitudeSymbol>()
					->tessellation() = 20;*/
					double depthOffset = this->getStyle().getOrCreate<osgEarth::Symbology::AltitudeSymbol>()
						->verticalOffset().value().eval();
					osg::Vec3d originPosition = inRenderGeometry.at(i);
					originPosition.z() = originPosition.z() + depthOffset;
					osgEarth::GeoPoint geoPosition(
						this->getMapNode()->getMapSRS(),
						originPosition);

					osg::Vec3d worldPoint;
					geoPosition.toWorld(worldPoint);
					outRenderGeometry.push_back(worldPoint);
					referenceCenter += worldPoint;
				}
				referenceCenter /= inRenderGeometry.size();
			}
		}
	}

	osg::Node* CGeoLine::createNode(
		std::vector<osg::Vec3d>& renderGeometry,
		osgEarth::Symbology::Style& renderStyle,
		osgEarth::MapNode* pMapNode)
	{
		if (this->getUseCustomRenderMode())
		{
			if (renderGeometry.size() >= 2)
			{
				osgEarth::Symbology::Color color = renderStyle.getOrCreate<LineSymbol>()->stroke()->color();
				float width = renderStyle.getOrCreate<LineSymbol>()->stroke()->width().get();

				osg::ref_ptr<osg::Vec4Array> colors = new osg::Vec4Array;
				colors->push_back(color);
				osg::ref_ptr<osg::Vec3Array> vertices = new osg::Vec3Array;
				std::vector<unsigned short> indices;
				std::vector<osg::Vec3d> worldGeometry;
				osg::Vec3d referenceCenter(0,0,0);
				this->computeRenderGeometry(
					renderGeometry,
					worldGeometry,
					referenceCenter);
				for (int i = 0 ; i < worldGeometry.size(); ++i)
				{
					osg::Vec3d relativePoint = worldGeometry[i] - referenceCenter;
					vertices->push_back(relativePoint);
					if (i < worldGeometry.size() - 1)
					{
						indices.push_back(i);
						indices.push_back(i+1);
					}
				}

				unsigned short* pIndices = new unsigned short[indices.size()];
				for (int i = 0; i < indices.size(); ++i)
				{
					pIndices[i] = indices[i];
				}
				int numIndices = sizeof(pIndices) / sizeof(unsigned short);
				numIndices = indices.size();
				osg::ref_ptr<osg::Geometry> pGeometry = new osg::Geometry;
				pGeometry->setColorArray(colors.get());
				pGeometry->setVertexArray(vertices.get());
				pGeometry->setColorBinding(osg::Geometry::BIND_OVERALL);

				pGeometry->addPrimitiveSet(new osg::DrawElementsUShort(osg::PrimitiveSet::LINES, numIndices, pIndices));
				osg::StateSet* stateset = new osg::StateSet;  //透明属性设置
				stateset->setMode(GL_BLEND, osg::StateAttribute::ON); //Alpha混合开启 
				stateset->setMode(GL_DEPTH_TEST, osg::StateAttribute::OFF); //取消深度测试 
				//GL_POINT_SMOOTH_HINT
				stateset->setMode(GL_LINE_SMOOTH, osg::StateAttribute::ON);
				stateset->setMode(GL_LIGHTING, osg::StateAttribute::OFF /*| osg::StateAttribute::PROTECTED*/);
				stateset->setAttributeAndModes(new osg::LineWidth(width), osg::StateAttribute::ON);
				stateset->setRenderingHint(osg::StateSet::TRANSPARENT_BIN);
				stateset->setRenderBinDetails(5, "RenderBin");

				osg::Geode* pSegment = new osg::Geode;//扇体节点
				pGeometry->setStateSet(stateset);
				pSegment->addDrawable(pGeometry.get());

				osg::MatrixTransform* pRealSegment = new osg::MatrixTransform;
				pRealSegment->addChild(pSegment);

				osg::Matrixd worldMatrix;
				worldMatrix.setTrans(referenceCenter);
				pRealSegment->setMatrix(worldMatrix);
				return pRealSegment;
			}
		}
		else
		{
			osgEarth::Annotation::FeatureNode* pathNode = NULL;
			if (renderGeometry.size() >= 2)
			{
				osgEarth::Symbology::Geometry* path = new osgEarth::Symbology::LineString();
				for (int i = 0; i < renderGeometry.size(); ++i)
				{
					osg::Vec3d& point = renderGeometry.at(i);
					path->push_back(point);
				}
				osg::Vec3d geoPosition = path->at(0);

				osgEarth::Features::Feature* pathFeature = new osgEarth::Features::Feature(
					path, pMapNode->getMapSRS(), renderStyle);
				pathFeature->geoInterp() = GEOINTERP_GREAT_CIRCLE;
				pathNode = new osgEarth::Annotation::FeatureNode(pMapNode, pathFeature,
					renderStyle, osgEarth::Features::GeometryCompilerOptions());
			}
			return pathNode;
		}
		return NULL;
	}
	
	bool CGeoLine::transformRenderGeometry(std::vector<osg::Vec3d>& outRenderGeometry)
	{
		outRenderGeometry = this->getGeometry();
		return outRenderGeometry.size() >= 2;
	}
	
	bool CGeoLine::loadToScene(std::vector<osg::Vec3d>& renderGeometry)
	{
		bool r = false;
		if (renderGeometry.size() >= 2)
		{
			this->getStyle().remove<osgEarth::Symbology::PolygonSymbol>();
			osg::Node* pathNode = this->createNode(
				renderGeometry,
				this->getStyle(),
				this->getMapNode());
			this->mpNode = pathNode;
 			if (NULL == this->mpLod)
			{
				this->mpLod = new osg::LOD();
			}
			this->mpLod->addChild(pathNode, 0, 10000000000);
			r = true;
		}
		return r;
	}

}
