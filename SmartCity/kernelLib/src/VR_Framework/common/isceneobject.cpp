//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 蚂蚁空间信息平台
//  @ File Name : isceneobject.cpp
//  @ Date : 2017/8/21
//  @ Author : 
//
//


#include "framework/common/isceneobject.h"


namespace Common
{
	
	ISceneObject::ISceneObject()
	{
		this->mSelectable = true;
		this->mVisible = true;
		this->mpRefMapNode = NULL;
		this->mpLod = NULL;
		this->mState = SOS_NONE;
		this->mGeoPosition = osg::Vec3d(0,0,0);
		this->mMaxGeometryPointNum = INT_MAX;
	}

	ISceneObject::ISceneObject(osgEarth::MapNode* pRefMapNode)
	{
		this->mSelectable = true;
		this->mVisible = true;
		this->mpRefMapNode = pRefMapNode;
		this->mpLod = NULL;
		this->mState = SOS_NONE;
		this->mMaxGeometryPointNum = INT_MAX;
	}

	void ISceneObject::setMapNode(osgEarth::MapNode* pRefMapNode)
	{
		this->mpRefMapNode = pRefMapNode;
	}

	osgEarth::MapNode* ISceneObject::getMapNode()
	{
		return this->mpRefMapNode;
	}

	ISceneObject::~ISceneObject()
	{

	}

	void ISceneObject::setState(const Common::ISceneObject::SceneObjectState& state)
	{
		this->mState = state;
	}

	Common::ISceneObject::SceneObjectState ISceneObject::getState()
	{
		return this->mState;
	}

	osg::LOD* ISceneObject::getOrCreateLod(const bool& needCreate)
	{
		if (needCreate && NULL == this->mpLod)
			this->mpLod = new osg::LOD();
		return this->mpLod;
	}
    
    bool ISceneObject::getSelectable()
    {
		return this->mSelectable;
    }
    
	bool ISceneObject::getVisible()
    {
		return this->mVisible;
    }

	void ISceneObject::setSelectable(const bool& selectable)
	{
		this->mSelectable = selectable;
	}

	void ISceneObject::setVisible(const bool& visible)
	{
		this->mVisible = visible;
		if (this->mpLod)
		{
			this->mpLod->setNodeMask(visible);
		}
	}
    

	bool ISceneObject::loadToScene()
	{
		throw std::exception("ISceneObject::loadToScene()!");
	}

	bool ISceneObject::renderToScene()
	{
		throw std::exception("ISceneObject::renderToScene()!");
	}

	bool ISceneObject::deRenderFromScene()
	{
		throw std::exception("ISceneObject::deRenderFromScene()!");
	}

	bool ISceneObject::unLoadFromScene()
	{
		throw std::exception("ISceneObject::unLoadFromScene()!");
	}

	bool ISceneObject::asynLock()
	{
		int r = this->mAsynLock.lock();
		return r == 0;
	}

	bool ISceneObject::asynUnlock()
	{
		int r = this->mAsynLock.unlock();
		return r == 0;
	}

	osg::BoundingBox& ISceneObject::getBoundingBox()
	{
		return this->mBox;
	}

	void ISceneObject::setBoundingBox(const osg::BoundingBox& box)
	{
		this->mBox = box;
	}

	osg::BoundingSphere& ISceneObject::getBoundingSphere()
	{
		return this->mBoundingSphere;
	}

	void ISceneObject::setBoundingSphere(const osg::BoundingSphere& box)
	{
		this->mBoundingSphere = box;
	}

	void ISceneObject::setGeoPosition(const osg::Vec3d& geoPosition)
	{
		this->mGeoPosition = geoPosition;
	}

	osg::Vec3d& ISceneObject::getGeoPosition()
	{
		return this->mGeoPosition;
	}

	std::vector<osg::Vec3d>& ISceneObject::getGeometry()
	{
		return this->mGeometry;
	}

	void ISceneObject::copyTo(Common::ISceneObject* pDestObject)
	{
		ISceneObject* pSceneObject = 
			dynamic_cast<ISceneObject*>(pDestObject);
		if (pSceneObject)
		{
			pSceneObject->getGeometry() = this->getGeometry();
			pSceneObject->getStyle() = this->getStyle();
		}
	}

	int ISceneObject::getMaxGeometryPointNum()
	{
		return this->mMaxGeometryPointNum;
	}

	osgEarth::Symbology::Style& ISceneObject::getStyle()
	{
		return this->mStyle;
	}

	bool ISceneObject::contain(const osg::Vec3d& geoPoint)
	{
		return false;
	}

	void ISceneObject::move(const osg::Vec3d& fromGeoPoint,const osg::Vec3d& toGeoPoint)
	{
		if (this->mpRefMapNode && this->getGeometry().size() > 1)
		{
			osg::Vec3d fromWorldPos,toWorldPos;
			osgEarth::GeoPoint geoStartPoint(mpRefMapNode->getMapSRS(), fromGeoPoint, osgEarth::ALTMODE_ABSOLUTE);
			geoStartPoint.toWorld(fromWorldPos);

			osgEarth::GeoPoint geoToPoint(mpRefMapNode->getMapSRS(), toGeoPoint, osgEarth::ALTMODE_ABSOLUTE);
			geoToPoint.toWorld(toWorldPos);

			osg::Vec3d moveDir = toWorldPos - fromWorldPos;
			for (int i = 0; i < this->getGeometry().size(); ++i)
			{
				osg::Vec3d geoPosition = this->getGeometry().at(i);
				osgEarth::GeoPoint curGeoPoint(mpRefMapNode->getMapSRS(), 
					geoPosition, osgEarth::ALTMODE_ABSOLUTE);
				osg::Vec3d worldPosition;
				curGeoPoint.toWorld(worldPosition);

				worldPosition += moveDir;
				curGeoPoint.fromWorld(mpRefMapNode->getMapSRS(),worldPosition);
				this->getGeometry()[i] = curGeoPoint.vec3d();
			}
		}
	}

	void ISceneObject::findVisibleSceneObject(osg::Camera* pCamera, osg::NodeVisitor* nv)
	{
		throw std::exception("ISceneObject::unLoadFromScene()!");
	}

	void ISceneObject::updateSceneObject()
	{
		throw std::exception("ISceneObject::unLoadFromScene()!");
	}

}
