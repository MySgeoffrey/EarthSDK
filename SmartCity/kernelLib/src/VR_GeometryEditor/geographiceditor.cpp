#include "geometryeditor/geographiceditor.h"

#if _use_newmode_ == 0
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : IGeoGraphicEditor.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geometryeditor/geographiceditor.h"
#include "geographic/geographiccreator.h"
#include "framework/core/igeoline.h"
#include "framework/core/igeopoint.h"
#include "framework/core/igeopolygon.h"
#include "framework/common/languageconfig.h"

namespace GeometryEditor
{
	/*bool isInSegment(osg::Vec3d p1,osg::Vec3d p2,osg::Vec3d q)
	{
	if(((q.x()-p1.x())*(p1.y()-p2.y()))==((p1.x()-p2.x())*(q.y()-p1.y()))
	&& (q.x()>=min(p1.x(),p2.x()) && q.x()<=max(p1.x(),p2.x()))
	&&  ((q.y()>=min(p1.y(),p2.y()))&&(q.y()<=max(p1.y(),p2.y()))))
	return true;
	return false;
	}*/

	/// <summary>
	/// 判断P是否在以P1,P2为对角顶点的矩形内。
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool  IsOnRectangle(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		double max_x = p1.x() > p2.x() ? p1.x() : p2.x();
		double min_x = p1.x() < p2.x() ? p1.x() : p2.x();
		double max_y = p1.y() > p2.y() ? p1.y() : p2.y();
		double min_y = p1.y() < p2.y() ? p1.y() : p2.y();
		if (p.x() >= min_x && p.x() <= max_x && p.y() >= min_y && p.y() <= max_y)
			return true;
		else
			return false;
	}

	/// <summary>
	/// (P1-P) * (P2 - P) = 0;判断三线共线
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool IsDirection(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		double result = (p1.x() - p.x()) * (p2.y() - p.y()) - (p2.x() - p.x()) * (p1.y() - p.y());
		if (std::abs(result) < 0.002)
			return true;
		return false;
	}

	/// <summary>
	/// 判断点p是否在以p1,p2的线段上。
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool IsOnSegment(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		if (IsDirection(p1, p2, p))
		{
			if (IsOnRectangle(p1, p2, p))
			{
				return true;
			}
			else
				return false;
		}
		else
			return false;
	}

	IGeoGraphicEditor::IGeoGraphicEditor(osgEarth::MapNode* pRefMapNode)
		: IPolygonEditor(pRefMapNode)
	{
		this->mpEditingObject = NULL;
		this->mpRefUserObject = NULL;
		this->mpEditContent = NULL;
		this->mExistMovePoint = false;
		this->mMouseDownAppendPointMode = true;
		this->mHighLightColor = osgEarth::Symbology::Color::Red;
		this->mHighLightWidth = 5;
		this->mNeedInsertPointByMouse = true;
	}

	IGeoGraphicEditor::~IGeoGraphicEditor()
	{
		if (this->mpEditContent)
		{
			this->mpEditContent->deRenderFromScene();
			this->mpEditContent->unLoadFromScene();
			this->mpEditContent = NULL;
		}
	}

	void IGeoGraphicEditor::beginEdit(
		const std::string& graphicType,
		Common::ISceneObject* pGraphicObject,
		const bool& hideOriginGraphicObject)
	{
		if (pGraphicObject != NULL
			&& pGraphicObject->getType() != graphicType)
			throw std::exception("") ;

		//初始化编辑环境
		IPolygonEditor::beginEdit();
		this->mpEditingObject = Graphic::CGeoGraphicCreator::createGraphicObject(graphicType,this->mpRefMapNode);
		if (NULL != this->mpEditingObject)
		{
			if (pGraphicObject)
			{
				this->mpRefUserObject = pGraphicObject;
				if (hideOriginGraphicObject)
				{
					this->mpRefUserObject->deRenderFromScene();
					this->mpRefUserObject->unLoadFromScene();
				}
				std::vector<osg::Vec3d>& geometry = pGraphicObject->getGeometry();
				for (int i = 0; i < geometry.size() > 0; ++i)
				{
					IEditPoint* pCurrentPoint = new IEditPoint();
					pCurrentPoint->setIndex(i);
					pCurrentPoint->setGeoPosition(geometry.at(i));
					this->getGeometry().push_back(pCurrentPoint);
				}
				this->mpRefUserObject->copyTo(this->mpEditingObject);
			}
			else
			{
				this->mpEditingObject->getStyle() = this->getGeometryStyle();
			}
			//高亮颜色处理
			osgEarth::Symbology::Style& curStyle =  this->mpEditingObject->getStyle();
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width() = this->mHighLightWidth;
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color() = this->mHighLightColor;

			this->mpEditingObject->loadToScene();
			this->mpEditingObject->renderToScene();
			//初始化当前场景编辑对象
			this->initial();

			if (NULL == this->mpEditContent)
			{
				this->mpEditContent = new Graphic::CGeoPoint(mpRefMapNode);
				osgEarth::Symbology::Style& style =  this->mpEditContent->getStyle();
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->fill() = osgEarth::Symbology::Color::Yellow;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->size() = 15;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloBackdropType() = osgText::Text::BackdropType::OUTLINE;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloImplementation() =  osgText::Text::BackdropImplementation::STENCIL_BUFFER;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->color() =osgEarth::Symbology::Color(0,0,0,1);
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->pixelOffset() = osg::Vec2s(5,5);
				style.getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral("");//设置点图标显示的图片
			}
			std::string content = osgEarth::Stringify() << this->mpEditingObject->getMaxGeometryPointNum();
			if (this->mpEditingObject->getMaxGeometryPointNum() > 10)
			{
				content = CLanguageConfig::getValue(CLanguageConfig::GraphicEdit_InfiniteText);
			}
			else
			{
				std::string format = CLanguageConfig::getValue(CLanguageConfig::GraphicEdit_FiniteText);
				//content = "鼠标选择" + content + "个点后绘制图形,右键结束";
				char str[255];
				sprintf(str,format.c_str(),content.c_str());
				content = str;
			}
			this->mpEditContent->setName(content);
			this->mpEditContent->loadToScene();
			this->mpEditContent->renderToScene();
		}
		else
		{
			throw std::exception("");
		}
	}

	bool IGeoGraphicEditor::endEdit(
		const bool& clearCurrentGeometry ,
		const bool& needSaveEditingResult ,
		const bool& hideOriginGraphicObject )
	{
		if (this->mpEditingObject)
		{
			if (this->mExistMovePoint)
			{
				int size = this->mpEditingObject->getGeometry().size();
				if (size > 0)
				{
					this->mpEditingObject->getGeometry().erase(
						this->mpEditingObject->getGeometry().begin() + size - 1);
				}
				this->mExistMovePoint = false;
			}
			if (this->mpRefUserObject)
			{
				//若开启的时候卸载了，此时要渲染出来
				if (hideOriginGraphicObject)
				{
					this->mpRefUserObject->loadToScene();
					this->mpRefUserObject->renderToScene();
				}
				this->mpRefUserObject = NULL;
				this->mpEditingObject->deRenderFromScene();
				this->mpEditingObject->unLoadFromScene();
				delete this->mpEditingObject;
				this->mpEditingObject = NULL;
			}
			else
			{
				if (this->mpEditingObject)
				{
					this->mpEditingObject->deRenderFromScene();
					this->mpEditingObject->unLoadFromScene();
					this->mpEditingObject->loadToScene();
					this->mpEditingObject->renderToScene();
				}
			}
		}

		return IPolygonEditor::endEdit(
			clearCurrentGeometry,
			needSaveEditingResult,
			hideOriginGraphicObject);
	}

	Common::ISceneObject* IGeoGraphicEditor::generateSceneObject()
	{
		Common::ISceneObject* pResult = NULL;
		if (this->mpEditingObject)
		{
			if (this->mExistMovePoint)
			{
				int size = this->mpEditingObject->getGeometry().size();
				if (size > 0)
				{
					this->mpEditingObject->getGeometry().erase(
						this->mpEditingObject->getGeometry().begin() + size - 1);
				}
				this->mExistMovePoint = false;
			}
			if (this->mpRefUserObject)
			{
				//高亮颜色处理
				osgEarth::Symbology::Style& curStyle =  this->mpRefUserObject->getStyle();
				float width = curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->width().get();
				osgEarth::Symbology::Color color = curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->color();
				this->mpEditingObject->copyTo(this->mpRefUserObject);
				curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->width() = width;
				curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->color() = color;
				pResult = this->mpRefUserObject;
			}
			else
			{
				this->mpEditingObject->getStyle() = this->getGeometryStyle();
				pResult = this->mpEditingObject;
			}
		}

		return pResult;
	}

	void IGeoGraphicEditor::initial()
	{
		if (this->mpGeometryNode == NULL)
		{
			osgEarth::Features::Feature* pFeature = new osgEarth::Features::Feature(
				new osgEarth::Symbology::PointSet,
				this->mpRefMapNode->getMapSRS());

			this->mpGeometryNode = new osgEarth::Annotation::FeatureNode(
				this->mpRefMapNode, pFeature,this->getPointsEditStyle());
			this->mpRefMapNode->addChild(this->mpGeometryNode);
		}

		osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
		pGeometry->clear();
		for (int i = 0; i < this->getGeometry().size(); ++i)
		{
			IEditPoint* pPoint = this->getGeometry().at(i);
			pGeometry->push_back(pPoint->getGeoPosition());
		}
		this->mpGeometryNode->init();

		if (this->mpPointsEdit != NULL)
		{
			int count = this->mpPointsEdit->getNumChildren();
			this->mpPointsEdit->removeChildren(0, count);
			this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
			this->mpPointsEdit = NULL;
		}
		this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
		this->mpPointsEdit->setSize(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
		this->mpPointsEdit->setColor(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
		this->mpRefMapNode->addChild(this->mpPointsEdit);

		this->createEditorCallBack();
	}

	void IGeoGraphicEditor::setHighLightInfo(
		const osgEarth::Symbology::Color& highLightColor,
		const double& highLightWidth)
	{
		this->mHighLightColor = highLightColor;
		this->mHighLightWidth = highLightWidth;
		if (this->mpEditingObject)
		{
			//高亮颜色处理
			osgEarth::Symbology::Style& curStyle =  this->mpEditingObject->getStyle();
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width() = this->mHighLightWidth;
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color() = this->mHighLightColor;
			this->mpEditingObject->deRenderFromScene();
			this->mpEditingObject->unLoadFromScene();
			this->mpEditingObject->loadToScene();
			this->mpEditingObject->renderToScene();
		}
	}

	void IGeoGraphicEditor::setNeedInsertPointByMouse(const bool& value)
	{
		this->mNeedInsertPointByMouse = value;
	}

	bool IGeoGraphicEditor::getNeedInsertPointByMouse()
	{
		return this->mNeedInsertPointByMouse;
	}

	void IGeoGraphicEditor::getHighLightInfo(
		osgEarth::Symbology::Color& highLightColor,
		double& highLightWidth)
	{
		highLightColor = this->mHighLightColor;
		highLightWidth = this->mHighLightWidth;
	}

	void IGeoGraphicEditor::performPicked(osg::Vec3d pos)
	{
		if (this->mExistMovePoint)
		{
			int size = this->mpEditingObject->getGeometry().size();
			if (size > 0)
			{
				this->mpEditingObject->getGeometry().erase(
					this->mpEditingObject->getGeometry().begin() + size - 1);
			}
			this->mExistMovePoint = false;
		}
		if (this->mpEditingObject 
			&& this->mpEditingObject->getGeometry().size() >= this->mpEditingObject->getMaxGeometryPointNum())
		{
			return ;
		}

		bool needInsertPoint = false;
		int beginIndex = -1,endIndex = -1;
		if (this->getNeedInsertPointByMouse())
		{
			//只有多边形，折线才需要插入点
			if (this->mpEditingObject->getMaxGeometryPointNum() > 10
				&& this->mpEditingObject->getGeometry().size() >= 2)
			{
				for (int i = 0 ; i < this->mpEditingObject->getGeometry().size(); ++i)
				{
					beginIndex = i ;
					endIndex = i + 1;
					if (i == this->mpEditingObject->getGeometry().size() - 1)
						endIndex = 0;
					osg::Vec3d beginPoint = this->mpEditingObject->getGeometry().at(beginIndex);
					osg::Vec3d endPoint = this->mpEditingObject->getGeometry().at(endIndex);

					bool inSegment = IsOnSegment(beginPoint,endPoint,pos);
					if (inSegment)
					{
						needInsertPoint = true;
						break;
					}
				}
			}
		}

		if (!needInsertPoint)
		{
			if (NULL != this->mpRefUserObject)
				return ;
			osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
			pGeometry->push_back(pos);
			this->mpGeometryNode->init();

			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().push_back(pos);
				this->mpEditingObject->updateSceneObject();
			}

			IEditPoint* pEditPoint = new IEditPoint();
			pEditPoint->setGeoPosition(pos);
			pEditPoint->setIndex(this->getGeometry().size());
			this->getGeometry().push_back(pEditPoint);
		}
		else
		{
			osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
			pGeometry->insert(pGeometry->begin() + beginIndex + 1,pos);
			this->mpGeometryNode->init();

			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().insert(this->mpEditingObject->getGeometry().begin() + beginIndex + 1,pos);
				this->mpEditingObject->updateSceneObject();
			}

			IEditPoint* pEditPoint = new IEditPoint();
			pEditPoint->setGeoPosition(pos);
			pEditPoint->setIndex(this->getGeometry().size());
			this->getGeometry().insert(this->getGeometry().begin() + beginIndex + 1 , pEditPoint);
			for (int n = 0 ; n < this->getGeometry().size(); ++n)
			{
				this->getGeometry().at(n)->setIndex(n);
			}
		}
		if (this->mpPointsEdit != NULL)
		{
			int count = this->mpPointsEdit->getNumChildren();
			this->mpPointsEdit->removeChildren(0, count);
			this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
			this->mpPointsEdit = NULL;
		}
		this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
		this->mpPointsEdit->setSize(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
		this->mpPointsEdit->setColor(this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
		this->mpRefMapNode->addChild(this->mpPointsEdit);
		this->createEditorCallBack();
	}

	void IGeoGraphicEditor::performMoving(osg::Vec3d pos)
	{
		if (this->mpEditingObject)
		{
			if (this->mpRefCurrentPoint)
			{
				this->mpEditingObject->getGeometry()[this->mpRefCurrentPoint->getIndex()] = pos;
				this->mpEditingObject->updateSceneObject();
			}
		}
	}

	bool IGeoGraphicEditor::performMoveGraphic(osg::Vec3d pos)
	{
		bool r = false;
		if (this->mpEditingObject)
		{
			if (NULL == this->mpRefCurrentPoint)
			{
				if (this->mpRefUserObject)
				{
					if (this->mpEditingObject->contain(this->mCurGeoPostion))
					{
						this->mpEditingObject->move(this->mCurGeoPostion,pos);
						this->mpEditingObject->updateSceneObject();

						osgEarth::Symbology::Geometry* pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
						pGeometry->clear();
						this->mpGeometryNode->init();
						if (this->mpPointsEdit != NULL)
						{
							int count = this->mpPointsEdit->getNumChildren();
							this->mpPointsEdit->removeChildren(0, count);
							this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
							this->mpPointsEdit = NULL;
						}
						r = true;
					}
				}
			}
			this->mCurGeoPostion = pos;
		}
		return r;
	}

	bool IGeoGraphicEditor::performEndMoveGraphic(osg::Vec3d pos)
	{
		if (this->mpEditingObject)
		{
			if (NULL == this->mpRefCurrentPoint)
			{
				if (this->mpRefUserObject)
				{
					if (this->mpPointsEdit == NULL)
					{
						osgEarth::Symbology::Geometry* pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
						for (int i = 0; i < this->mpEditingObject->getGeometry().size(); ++i)
						{
							osg::Vec3d geoPosition = this->mpEditingObject->getGeometry().at(i);
							pGeometry->push_back(geoPosition);
							this->getGeometry()[i]->setGeoPosition(geoPosition);
						}
						this->mpGeometryNode->init();

						this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
						this->mpPointsEdit->setSize(
							this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
						this->mpPointsEdit->setColor(this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
						this->mpRefMapNode->addChild(this->mpPointsEdit);
						this->createEditorCallBack();
					}
				}
			}
		}
		return false;
	}

	void IGeoGraphicEditor::performPickedXYZ(osg::Vec3d pos)
	{

	}

	void IGeoGraphicEditor::performMovingXYZ(osg::Vec3d pos)
	{
		if (NULL == this->mpRefUserObject)
		{
			if (this->mpEditContent)
			{
				this->mpEditContent->setGeoPosition(pos);
				this->mpEditContent->updateSceneObject();
			}
			int size = this->mpEditingObject->getGeometry().size();
			if (size > 0)
			{
				if (this->mExistMovePoint)
				{
					this->mpEditingObject->getGeometry()[size - 1] = pos;
				}
				else
				{
					this->mpEditingObject->getGeometry().push_back(pos);
					this->mExistMovePoint = true;
				}
				this->mpEditingObject->updateSceneObject();
			}
		}
	}

	void IGeoGraphicEditor::performRightPicked()
	{
#if 1
		//如果点不锅，无法结束
		if (this->mpEditingObject->getMaxGeometryPointNum() < 10)
		{
			int size = this->mpEditingObject->getGeometry().size();
			if (this->mExistMovePoint)
			{
				size -= 1;
			}
			if (size < this->mpEditingObject->getMaxGeometryPointNum())
				return ;
		}
#endif

		if (!mIsDragState)
		{
			if (this->mExistMovePoint)
			{
				int size = this->mpEditingObject->getGeometry().size();
				if (size > 0)
				{
					this->mpEditingObject->getGeometry().erase(
						this->mpEditingObject->getGeometry().begin() + size - 1);
					this->mpEditingObject->updateSceneObject();
				}
				this->mExistMovePoint = false;
			}
			IPolygonEditor::performRightPicked();
			if (this->mpEditContent)
			{
				this->mpEditContent->deRenderFromScene();
				this->mpEditContent->unLoadFromScene();
			}
		}
	}

	void IGeoGraphicEditor::performDeleteDrawing()
	{
		if (this->mpRefCurrentPoint)
		{
			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().erase(
					this->mpEditingObject->getGeometry().begin() + this->mpRefCurrentPoint->getIndex());
				this->mpEditingObject->updateSceneObject();
			}
		}
		IPolygonEditor::performDeleteDrawing();

	}
}

#else
//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : IGeoGraphicEditor.cpp
//  @ Date : 2018/7/28
//  @ Author : sgeoffrey
//  @platform:蚂蚁空间信息平台
//


#include "geometryeditor/geographiceditor.h"
#include "geographic/geographiccreator.h"
#include "framework/core/igeoline.h"
#include "framework/core/igeopoint.h"
#include "framework/core/igeopolygon.h"
#include "framework/common/languageconfig.h"

namespace GeometryEditor
{
	/*bool isInSegment(osg::Vec3d p1,osg::Vec3d p2,osg::Vec3d q)
	{
	if(((q.x()-p1.x())*(p1.y()-p2.y()))==((p1.x()-p2.x())*(q.y()-p1.y()))
	&& (q.x()>=min(p1.x(),p2.x()) && q.x()<=max(p1.x(),p2.x()))
	&&  ((q.y()>=min(p1.y(),p2.y()))&&(q.y()<=max(p1.y(),p2.y()))))
	return true;
	return false;
	}*/

	/// <summary>
	/// 判断P是否在以P1,P2为对角顶点的矩形内。
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool  IsOnRectangle(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		double max_x = p1.x() > p2.x() ? p1.x() : p2.x();
		double min_x = p1.x() < p2.x() ? p1.x() : p2.x();
		double max_y = p1.y() > p2.y() ? p1.y() : p2.y();
		double min_y = p1.y() < p2.y() ? p1.y() : p2.y();
		if (p.x() >= min_x && p.x() <= max_x && p.y() >= min_y && p.y() <= max_y)
			return true;
		else
			return false;
	}

	/// <summary>
	/// (P1-P) * (P2 - P) = 0;判断三线共线
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool IsDirection(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		double result = (p1.x() - p.x()) * (p2.y() - p.y()) - (p2.x() - p.x()) * (p1.y() - p.y());
		if (std::abs(result) < 0.002)
			return true;
		return false;
	}

	/// <summary>
	/// 判断点p是否在以p1,p2的线段上。
	/// </summary>
	/// <param name="p1"></param>
	/// <param name="p2"></param>
	/// <param name="p"></param>
	/// <returns></returns>
	static bool IsOnSegment(osg::Vec3d p1, osg::Vec3d p2, osg::Vec3d p)
	{
		if (IsDirection(p1, p2, p))
		{
			if (IsOnRectangle(p1, p2, p))
			{
				return true;
			}
			else
				return false;
		}
		else
			return false;
	}

	IGeoGraphicEditor::IGeoGraphicEditor(osgEarth::MapNode* pRefMapNode)
		: IPolygonEditor(pRefMapNode)
	{
		this->mpEditingObject = NULL;
		this->mpEditContent = NULL;
		this->mExistMovePoint = false;
		this->mMouseDownAppendPointMode = true;
		this->mHighLightColor = osgEarth::Symbology::Color::Red;
		this->mHighLightWidth = 5;
		this->mNeedInsertPointByMouse = true;
	}

	IGeoGraphicEditor::~IGeoGraphicEditor()
	{
		if (this->mpEditContent)
		{
			this->mpEditContent->deRenderFromScene();
			this->mpEditContent->unLoadFromScene();
			this->mpEditContent = NULL;
		}
	}

	void IGeoGraphicEditor::beginEdit(
		const std::string& graphicType,
		Common::ISceneObject* pGraphicObject,
		const bool& hideOriginGraphicObject)
	{
		if (pGraphicObject != NULL
			&& pGraphicObject->getType() != graphicType)
			throw std::exception("") ;

		//初始化编辑环境
		IPolygonEditor::beginEdit();
		this->mpEditingObject = pGraphicObject;
		if (this->mpEditingObject == NULL)
		{
			this->mpEditingObject = Graphic::CGeoGraphicCreator::createGraphicObject(graphicType,this->mpRefMapNode);
			//this->mpEditingObject->getStyle() = this->getGeometryStyle();
			this->mpEditingObject->getStyle().getOrCreate<osgEarth::Symbology::PolygonSymbol>()->fill()->color() =
				this->getGeometryStyle().getOrCreate<osgEarth::Symbology::PolygonSymbol>()->fill()->color();
			this->mpEditingObject->getStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width() = this->getGeometryStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width();
			this->mpEditingObject->getStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color() = this->getGeometryStyle().getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color();
		}
		if (NULL != this->mpEditingObject)
		{
			if (mpEditingObject)
			{
				if (hideOriginGraphicObject)
				{
					this->mpEditingObject->deRenderFromScene();
					this->mpEditingObject->unLoadFromScene();
				}
				std::vector<osg::Vec3d>& geometry = this->mpEditingObject->getGeometry();
				for (int i = 0; i < geometry.size() > 0; ++i)
				{
					IEditPoint* pCurrentPoint = new IEditPoint();
					pCurrentPoint->setIndex(i);
					pCurrentPoint->setGeoPosition(geometry.at(i));
					this->getGeometry().push_back(pCurrentPoint);
				}
			}
			
			//高亮颜色处理
			osgEarth::Symbology::Style& curStyle =  this->mpEditingObject->getStyle();
			this->mOutlineWidth = curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width().get();
			this->mGraphicColor = curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color();
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width() = this->mHighLightWidth;
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color() = this->mHighLightColor;

			this->mpEditingObject->loadToScene();
			this->mpEditingObject->renderToScene();
			//初始化当前场景编辑对象
			this->initial();

			if (NULL == this->mpEditContent)
			{
				this->mpEditContent = new Graphic::CGeoPoint(mpRefMapNode);
				osgEarth::Symbology::Style& style =  this->mpEditContent->getStyle();
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->fill() = osgEarth::Symbology::Color::Yellow;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->size() = 15;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloBackdropType() = osgText::Text::BackdropType::OUTLINE;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->haloImplementation() =  osgText::Text::BackdropImplementation::STENCIL_BUFFER;
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->halo()->color() =osgEarth::Symbology::Color(0,0,0,1);
				style.getOrCreate<osgEarth::Symbology::TextSymbol>()->pixelOffset() = osg::Vec2s(5,5);
				style.getOrCreate<osgEarth::Annotation::IconSymbol>()->url()->setLiteral("");//设置点图标显示的图片
			}
			std::string content = osgEarth::Stringify() << this->mpEditingObject->getMaxGeometryPointNum();
			if (this->mpEditingObject->getMaxGeometryPointNum() > 10)
			{
				content = CLanguageConfig::getValue(CLanguageConfig::GraphicEdit_InfiniteText);
			}
			else
			{
				std::string format = CLanguageConfig::getValue(CLanguageConfig::GraphicEdit_FiniteText);
				//content = "鼠标选择" + content + "个点后绘制图形,右键结束";
				char str[255];
				sprintf(str,format.c_str(),content.c_str());
				content = str;
			}
			this->mpEditContent->setName(content);
			this->mpEditContent->loadToScene();
			this->mpEditContent->renderToScene();
		}
		else
		{
			throw std::exception("");
		}
	}

	bool IGeoGraphicEditor::endEdit(
		const bool& clearCurrentGeometry ,
		const bool& needSaveEditingResult ,
		const bool& hideOriginGraphicObject )
	{
		if (this->mpEditingObject)
		{
			if (this->mExistMovePoint)
			{
				int size = this->mpEditingObject->getGeometry().size();
				if (size > 0)
				{
					this->mpEditingObject->getGeometry().erase(
						this->mpEditingObject->getGeometry().begin() + size - 1);
				}
				this->mExistMovePoint = false;
			}
			//若开启的时候卸载了，此时要渲染出来
			if (hideOriginGraphicObject)
			{
				osgEarth::Symbology::Style& curStyle =  this->mpEditingObject->getStyle();
				curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->width() = this->mOutlineWidth;
				curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
					->stroke()->color() = this->mGraphicColor;
				this->mpEditingObject->deRenderFromScene();
				this->mpEditingObject->unLoadFromScene();
				this->mpEditingObject->loadToScene();
				this->mpEditingObject->renderToScene();
			}
		}

		return IPolygonEditor::endEdit(
			clearCurrentGeometry,
			needSaveEditingResult,
			hideOriginGraphicObject);
	}

	Common::ISceneObject* IGeoGraphicEditor::generateSceneObject()
	{
		return this->mpEditingObject;
	}

	void IGeoGraphicEditor::initial()
	{
		if (this->mpGeometryNode == NULL)
		{
			osgEarth::Features::Feature* pFeature = new osgEarth::Features::Feature(
				new osgEarth::Symbology::PointSet,
				this->mpRefMapNode->getMapSRS());

			this->mpGeometryNode = new osgEarth::Annotation::FeatureNode(
				this->mpRefMapNode, pFeature,this->getPointsEditStyle());
			this->mpRefMapNode->addChild(this->mpGeometryNode);
		}

		osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
		pGeometry->clear();
		for (int i = 0; i < this->getGeometry().size(); ++i)
		{
			IEditPoint* pPoint = this->getGeometry().at(i);
			pGeometry->push_back(pPoint->getGeoPosition());
		}
		this->mpGeometryNode->init();

		if (this->mpPointsEdit != NULL)
		{
			int count = this->mpPointsEdit->getNumChildren();
			this->mpPointsEdit->removeChildren(0, count);
			this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
			this->mpPointsEdit = NULL;
		}
		this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
		this->mpPointsEdit->setSize(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
		this->mpPointsEdit->setColor(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
		this->mpRefMapNode->addChild(this->mpPointsEdit);

		this->createEditorCallBack();
	}

	void IGeoGraphicEditor::setHighLightInfo(
		const osgEarth::Symbology::Color& highLightColor,
		const double& highLightWidth)
	{
		this->mHighLightColor = highLightColor;
		this->mHighLightWidth = highLightWidth;
		if (this->mpEditingObject)
		{
			//高亮颜色处理
			osgEarth::Symbology::Style& curStyle =  this->mpEditingObject->getStyle();
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->width() = this->mHighLightWidth;
			curStyle.getOrCreate<osgEarth::Symbology::LineSymbol>()
				->stroke()->color() = this->mHighLightColor;
			this->mpEditingObject->deRenderFromScene();
			this->mpEditingObject->unLoadFromScene();
			this->mpEditingObject->loadToScene();
			this->mpEditingObject->renderToScene();
		}
	}

	void IGeoGraphicEditor::setNeedInsertPointByMouse(const bool& value)
	{
		this->mNeedInsertPointByMouse = value;
	}

	bool IGeoGraphicEditor::getNeedInsertPointByMouse()
	{
		return this->mNeedInsertPointByMouse;
	}

	void IGeoGraphicEditor::getHighLightInfo(
		osgEarth::Symbology::Color& highLightColor,
		double& highLightWidth)
	{
		highLightColor = this->mHighLightColor;
		highLightWidth = this->mHighLightWidth;
	}

	void IGeoGraphicEditor::performPicked(osg::Vec3d pos)
	{
		if (this->mExistMovePoint)
		{
			int size = this->mpEditingObject->getGeometry().size();
			if (size > 0)
			{
				this->mpEditingObject->getGeometry().erase(
					this->mpEditingObject->getGeometry().begin() + size - 1);
			}
			this->mExistMovePoint = false;
		}
		if (this->mpEditingObject 
			&& this->mpEditingObject->getGeometry().size() >= this->mpEditingObject->getMaxGeometryPointNum())
		{
			return ;
		}

		bool needInsertPoint = false;
		int beginIndex = -1,endIndex = -1;
		if (this->getNeedInsertPointByMouse())
		{
			//只有多边形，折线才需要插入点
			if (this->mpEditingObject->getMaxGeometryPointNum() > 10
				&& this->mpEditingObject->getGeometry().size() >= 2)
			{
				for (int i = 0 ; i < this->mpEditingObject->getGeometry().size(); ++i)
				{
					beginIndex = i ;
					endIndex = i + 1;
					if (i == this->mpEditingObject->getGeometry().size() - 1)
						endIndex = 0;
					osg::Vec3d beginPoint = this->mpEditingObject->getGeometry().at(beginIndex);
					osg::Vec3d endPoint = this->mpEditingObject->getGeometry().at(endIndex);

					bool inSegment = IsOnSegment(beginPoint,endPoint,pos);
					if (inSegment)
					{
						needInsertPoint = true;
						break;
					}
				}
			}
		}

		if (!needInsertPoint)
		{
			osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
			pGeometry->push_back(pos);
			this->mpGeometryNode->init();

			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().push_back(pos);
				this->mpEditingObject->updateSceneObject();
			}

			IEditPoint* pEditPoint = new IEditPoint();
			pEditPoint->setGeoPosition(pos);
			pEditPoint->setIndex(this->getGeometry().size());
			this->getGeometry().push_back(pEditPoint);
		}
		else
		{
			osg::ref_ptr<osgEarth::Symbology::Geometry> pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
			pGeometry->insert(pGeometry->begin() + beginIndex + 1,pos);
			this->mpGeometryNode->init();

			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().insert(this->mpEditingObject->getGeometry().begin() + beginIndex + 1,pos);
				this->mpEditingObject->updateSceneObject();
			}

			IEditPoint* pEditPoint = new IEditPoint();
			pEditPoint->setGeoPosition(pos);
			pEditPoint->setIndex(this->getGeometry().size());
			this->getGeometry().insert(this->getGeometry().begin() + beginIndex + 1 , pEditPoint);
			for (int n = 0 ; n < this->getGeometry().size(); ++n)
			{
				this->getGeometry().at(n)->setIndex(n);
			}
		}
		if (this->mpPointsEdit != NULL)
		{
			int count = this->mpPointsEdit->getNumChildren();
			this->mpPointsEdit->removeChildren(0, count);
			this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
			this->mpPointsEdit = NULL;
		}
		this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
		this->mpPointsEdit->setSize(
			this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
		this->mpPointsEdit->setColor(this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
		this->mpRefMapNode->addChild(this->mpPointsEdit);
		this->createEditorCallBack();
	}

	void IGeoGraphicEditor::performMoving(osg::Vec3d pos)
	{
		if (this->mpEditingObject)
		{
			if (this->mpRefCurrentPoint)
			{
				this->mpEditingObject->getGeometry()[this->mpRefCurrentPoint->getIndex()] = pos;
				this->mpEditingObject->updateSceneObject();
			}
		}
	}

	bool IGeoGraphicEditor::performMoveGraphic(osg::Vec3d pos)
	{
		bool r = false;
		if (this->mpEditingObject)
		{
			if (NULL == this->mpRefCurrentPoint)
			{
				if (this->mpEditingObject->contain(this->mCurGeoPostion))
				{
					this->mpEditingObject->move(this->mCurGeoPostion,pos);
					this->mpEditingObject->updateSceneObject();

					osgEarth::Symbology::Geometry* pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
					pGeometry->clear();
					this->mpGeometryNode->init();
					if (this->mpPointsEdit != NULL)
					{
						int count = this->mpPointsEdit->getNumChildren();
						this->mpPointsEdit->removeChildren(0, count);
						this->mpPointsEdit->getParent(0)->removeChild(this->mpPointsEdit);
						this->mpPointsEdit = NULL;
					}
					r = true;
				}
			}
			this->mCurGeoPostion = pos;
		}
		return r;
	}

	bool IGeoGraphicEditor::performEndMoveGraphic(osg::Vec3d pos)
	{
		if (this->mpEditingObject)
		{
			if (NULL == this->mpRefCurrentPoint)
			{
				if (this->mpPointsEdit == NULL)
				{
					osgEarth::Symbology::Geometry* pGeometry = this->mpGeometryNode->getFeature()->getGeometry();
					for (int i = 0; i < this->mpEditingObject->getGeometry().size(); ++i)
					{
						osg::Vec3d geoPosition = this->mpEditingObject->getGeometry().at(i);
						pGeometry->push_back(geoPosition);
						this->getGeometry()[i]->setGeoPosition(geoPosition);
					}
					this->mpGeometryNode->init();

					this->mpPointsEdit = new osgEarth::Annotation::FeatureEditor(this->mpGeometryNode);
					this->mpPointsEdit->setSize(
						this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->size().get());
					this->mpPointsEdit->setColor(this->getPointsEditStyle().getOrCreateSymbol<osgEarth::Symbology::PointSymbol>()->fill()->color());
					this->mpRefMapNode->addChild(this->mpPointsEdit);
					this->createEditorCallBack();
				}
			}
		}
		return false;
	}

	void IGeoGraphicEditor::performPickedXYZ(osg::Vec3d pos)
	{

	}

	void IGeoGraphicEditor::performMovingXYZ(osg::Vec3d pos)
	{
		{
			if (this->mpEditContent)
			{
				this->mpEditContent->setGeoPosition(pos);
				this->mpEditContent->updateSceneObject();
			}

			int size = this->mpEditingObject->getGeometry().size();
			if (size > 0)
			{
				if (this->mExistMovePoint)
				{
					this->mpEditingObject->getGeometry()[size - 1] = pos;
				}
				else
				{
					this->mpEditingObject->getGeometry().push_back(pos);
					this->mExistMovePoint = true;
				}
				this->mpEditingObject->updateSceneObject();
			}
		}
	}

	void IGeoGraphicEditor::performRightPicked()
	{
#if 1
		//如果点不锅，无法结束
		if (this->mpEditingObject->getMaxGeometryPointNum() < 10)
		{
			int size = this->mpEditingObject->getGeometry().size();
			if (this->mExistMovePoint)
			{
				size -= 1;
			}
			if (size < this->mpEditingObject->getMaxGeometryPointNum())
				return ;
		}
#endif

		if (!mIsDragState)
		{
			if (this->mExistMovePoint)
			{
				int size = this->mpEditingObject->getGeometry().size();
				if (size > 0)
				{
					this->mpEditingObject->getGeometry().erase(
						this->mpEditingObject->getGeometry().begin() + size - 1);
					this->mpEditingObject->updateSceneObject();
				}
				this->mExistMovePoint = false;
			}
			IPolygonEditor::performRightPicked();
			if (this->mpEditContent)
			{
				this->mpEditContent->deRenderFromScene();
				this->mpEditContent->unLoadFromScene();
			}
		}
	}

	void IGeoGraphicEditor::performDeleteDrawing()
	{
		if (this->mpRefCurrentPoint)
		{
			if (this->mpEditingObject)
			{
				this->mpEditingObject->getGeometry().erase(
					this->mpEditingObject->getGeometry().begin() + this->mpRefCurrentPoint->getIndex());
				this->mpEditingObject->updateSceneObject();
			}
		}
		IPolygonEditor::performDeleteDrawing();

	}
}

#endif