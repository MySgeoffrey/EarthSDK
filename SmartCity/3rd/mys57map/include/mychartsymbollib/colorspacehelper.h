//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : MyS57Chart
//  @ File Name : ccolorspacehelper.h
//  @ Date : 2017/9/27
//  @ Author : sgeoffrey
//
//


#if !defined(_CCOLORSPACEHELPER_H)
#define _CCOLORSPACEHELPER_H

#include <math.h>
#include <QtGui/QColor>
#include <vector>
#include "mychartsymbollib/rgb.h"
#include "mychartsymbollib/ciexyz.h"
#include "mychartsymbollib/cieyxy.h"

namespace MyChart
{
	class CColorSpaceHelper
	{
	public:

		CColorSpaceHelper();

		virtual ~CColorSpaceHelper();

		static double GetColorDistance(double r1, double g1, double b1, double r2, double g2, double b2)
		{
			double a = r2 - r1;
			double b = g2 - g1;
			double c = b2 - b1;

			return sqrt(a * a + b * b + c * c);
		}

		 static double GetColorDistance(double color1[], double color2[])
		 {
			 return GetColorDistance(color1[0], color1[1], color1[2], color2[0], color2[1], color2[2]);
		 }

		 static double GetColorDistance(QColor c1, QColor c2)
		 {
			 double rgb1[] = {
				 (double)c1.red()/255.0,
					 (double)c1.green()/255.0,
					 (double)c1.blue()/255.0
			 };

			 double rgb2[] = {
				 (double)c2.red()/255.0,
					 (double)c2.green()/255.0,
					 (double)c2.blue()/255.0
			 };

			 return GetColorDistance(rgb1[0], rgb1[1], rgb1[2], rgb2[0], rgb2[1], rgb2[2]);
		 }

		 static std::vector<QColor> GetWheelColors(int alpha)
		 {
			 QColor temp;
			 int colorCount = 6 * 256;
			 std::vector<QColor> colors;

			 for (int i = 0; i < colorCount; i++)
			 {
				 throw std::exception("");
				 //temp = HSBtoColor((int)((double)(i * 255.0) / colorCount), 255, 255);
				 colors.push_back(QColor(temp.red(), temp.green(), temp.blue(),alpha));
			 }

			 return colors;
		 }

		 static std::vector<QColor> GetSpectrumColors(int alpha)
		 {
			 std::vector<QColor> colors;
			colors.resize(256 * 6);
			 //for(int i=127; i<256; i++) colors[i-127] = Color.FromArgb(alpha, i, 0, 0);
			 for (int i = 0; i < 256; i++) 
				 colors[i] = QColor(255, i, 0,alpha);
			 for (int i = 0; i < 256; i++) 
				 colors[i + (256)] = QColor(255 - i, 255, 0,alpha);
			 for (int i = 0; i < 256; i++) 
				 colors[i + (256 * 2)] = QColor(0, 255, i,alpha);
			 for (int i = 0; i < 256; i++) 
				 colors[i + (256 * 3)] = QColor(0, 255 - i, 255,alpha);
			 for (int i = 0; i < 256; i++) 
				 colors[i + (256 * 4)] = QColor(i, 0, 255,alpha);
			 for (int i = 0; i < 256; i++) 
				 colors[i + (256 * 5)] = QColor(255, 0, 255 - i,alpha);
			 //for(int i=0; i<128; i++) colors[i+(128+256*6)] = Color.FromArgb(alpha, 255-i, 0, 0);

			 return colors;
		 }

		 static std::vector<QColor> GetSpectrumColors()
		 {
			 return GetSpectrumColors(255);
		 }

		 static int GetIntFromHex(std::string strHex)
		 {
			 if (strHex == "A")
			 {
				 return 10;
			 }
			 else if (strHex == "B")
			 {
				 return 11;
			 }
			 else if (strHex == "C")
			 {
				 return 12;
			 }
			 else if (strHex == "D")
			 {
				 return 13;
			 }
			 else if (strHex == "E")
			 {
				 return 14;
			 }
			 else if (strHex == "F")
			 {
				 return 15;
			 }
			 else
			 {
				 return QString(strHex.c_str()).toInt();
			 }
		 }

		 static CRgb XYZtoRGB(double x, double y, double z)
		 {
			 //x = 0.00833755;
			 //y = 0.0093918;
			 //z = 0.0092977;
			 double Clinear[3];
			 Clinear[0] = x * 3.2410 - y * 1.5374 - z * 0.4986; // red
			 Clinear[1] = -x * 0.9692 + y * 1.8760 - z * 0.0416; // green
			 Clinear[2] = x * 0.0556 - y * 0.2040 + z * 1.0570; // blue
			 //Clinear[0] = x * 3.2406 - y * 1.5371 - z * 0.49895; // red
			 //Clinear[1] = -x * 0.96891 + y * 1.8757 - z * 0.041914; // green
			 //Clinear[2] = x * 0.055708 - y * 0.20401 + z * 1.057; // blue

			 for (int i = 0; i < 3; i++)
			 {
				 Clinear[i] = (Clinear[i] <= 0.0031308) ? 12.92 * Clinear[i] : (1 + 0.055) * std::pow(Clinear[i], (1.0 / 2.4)) - 0.055;
			 }

			 int r = (int)(QString::number(Clinear[0] * 255.0,'f',2).toDouble());
			 int g = (int)(QString::number(Clinear[1] * 255.0,'f',2).toDouble());
			 int b = (int)(QString::number(Clinear[2] * 255.0,'f',2).toDouble());
			 return CRgb(r,g,b);
		 }

		 static CRgb XYZtoRGB(CCIEXYZ xyz)
		 {
			 return XYZtoRGB(xyz.x(), xyz.y(), xyz.z());
		 }

		 static CCIEXYZ YxytoXYZ(double Y, double x, double y)
        {
            return CCIEXYZ(Y * x / y / 100, Y / 100, Y * (1 - x - y) / y / 100);
        }

		 static CCIEXYZ YxytoXYZ(CCIEYxy Yxy)
		 {
			 return YxytoXYZ(Yxy.Y(), Yxy.x(), Yxy.y());
		 }

		 /*static QColor HexToColor(std::string hexColor)
		 {
		 std::string r, g, b;

		 if (hexColor != "")
		 {
		 QString qHexColor(hexColor.c_str());
		 qHexColor = qHexColor.trimmed();
		 if (hexColor[0] == '#') hexColor = hexColor.Substring(1, hexColor.Length - 1);

		 r = hexColor.Substring(0, 2);
		 g = hexColor.Substring(2, 2);
		 b = hexColor.Substring(4, 2);

		 r = Convert.ToString(16 * GetIntFromHex(r.Substring(0, 1)) + GetIntFromHex(r.Substring(1, 1)));
		 g = Convert.ToString(16 * GetIntFromHex(g.Substring(0, 1)) + GetIntFromHex(g.Substring(1, 1)));
		 b = Convert.ToString(16 * GetIntFromHex(b.Substring(0, 1)) + GetIntFromHex(b.Substring(1, 1)));

		 return Color.FromArgb(Convert.ToInt32(r), Convert.ToInt32(g), Convert.ToInt32(b));
		 }

		 return Color.Empty;
		 }*/

		 static std::string RGBToHex(int r, int g, int b)
		 {
			 throw std::exception("");
			 //return String.Format("#{0:x2}{1:x2}{2:x2}", (int)r, (int)g, (int)b);
		 }

		 static std::string RGBToHex(QColor c)
		 {
			 return RGBToHex(c.red(), c.green(), c.blue());
		 }

		void Operation1();
	};
}
#endif  //_CCOLORSPACEHELPER_H
